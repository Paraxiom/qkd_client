diff --git a/Cargo.toml b/Cargo.toml
index e7dd6b6..24dd8ef 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -11,9 +11,7 @@ path = "src/lib.rs"
 name = "qkd_client"
 path = "src/main.rs"
 
-[[bin]]
-name = "setup_main"
-path = "src/bin/setup_main.rs"
+
 
 [dependencies]
 # Arkworks base
diff --git a/circuits/vrf_seed_proof_input.json b/circuits/vrf_seed_proof_input.json
index ee68634..ac6711b 100644
--- a/circuits/vrf_seed_proof_input.json
+++ b/circuits/vrf_seed_proof_input.json
@@ -1,5 +1,5 @@
 {
-  "inputData": "0x565246207465737420696e7075742066",
-  "quantumKey": "0x716334450d70fa1aaf76e8ff2f7af9e6",
-  "vrfSeed": "0xe755a8db8ecb11a9589c630d7bce6fac"
+  "inputData": "0x496e746567726174696f6e207465737420666f7220514b44207175616e74756d2d726573697374616e7420565246",
+  "quantumKey": "0xacb831d480a51a808f3613adf071da3c14122c59c37452a657b5369977c64772",
+  "vrfSeed": "0x2f24938bffe144121bb1821ca91673343be926d06372b8c2a4bd1cb8aa238eab8bb4330c280b699981e3bbd970f6f8fa9c1fbf81ebdd0c64de49b7f21bbe6e1b"
 }
\ No newline at end of file
diff --git a/circuits/vrf_seed_proof_proof.json b/circuits/vrf_seed_proof_proof.json
index 636fff8..650726e 100644
--- a/circuits/vrf_seed_proof_proof.json
+++ b/circuits/vrf_seed_proof_proof.json
@@ -1,17 +1,17 @@
 {
  "pi_a": [
-  "6549541717038800044573622964669335740428569585633626404583369603804348359539",
-  "10336046677882615847744072662209419948635854526365204409465820995143402510564",
+  "1937061703663816248338232570703638454555425365690035865041594443628848454821",
+  "20097682317821185028232458431737810950071927220994414724656595701429957650733",
   "1"
  ],
  "pi_b": [
   [
-   "7678945908302714824938083206944826534843216005626975090233913804580847323385",
-   "19096752070834345893716300089491478117505927031424272484876837269256237073491"
+   "13041577429027539071081802806457148521748171512349577895649492297352790634091",
+   "9104289294293145151435387652283702669244740202278947725282577663359297819169"
   ],
   [
-   "10597584531710061324588356990635705298130605643497956238308418192478177192992",
-   "19354828864930103121186918974715461489153603219319808757523047221565840020342"
+   "10298364342610562203068532455847447114431308247281342281954110917300887790295",
+   "14502339859359867349508031178843922716288857260876669572322544697382927173414"
   ],
   [
    "1",
@@ -19,8 +19,8 @@
   ]
  ],
  "pi_c": [
-  "10342810298443245430522936796307238057539905801289064705375270165437116517746",
-  "6005869275897487482081055586977664521864049997709388531568822681431926680887",
+  "7130651377037665150455168465830879648921301937751031438414603017767993652519",
+  "7426517879590819824447837185707421821451474964076650072166545352636158481611",
   "1"
  ],
  "protocol": "groth16",
diff --git a/circuits/vrf_seed_proof_witness.wtns b/circuits/vrf_seed_proof_witness.wtns
index f18f47a..e1f4274 100644
Binary files a/circuits/vrf_seed_proof_witness.wtns and b/circuits/vrf_seed_proof_witness.wtns differ
diff --git a/diff.txt b/diff.txt
index b1ad419..e69de29 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,687 +0,0 @@
-diff --git a/circuits/input.json b/circuits/input.json
-index 41ebc44..a873371 100644
---- a/circuits/input.json
-+++ b/circuits/input.json
-@@ -1 +1 @@
--{"key":[64,236,136,65,175,244,17,13,49,36,202,24,63,223,223,70,204,73,85,154,243,137,84,105,97,214,3,44,136,253,207,216]}
-\ No newline at end of file
-+{"key":[198,78,145,115,240,55,174,144,117,184,82,190,102,248,28,214,204,152,88,59,187,78,229,215,15,24,32,117,232,244,143,128]}
-\ No newline at end of file
-diff --git a/circuits/proof.json b/circuits/proof.json
-index f3d54e9..1c489d4 100644
---- a/circuits/proof.json
-+++ b/circuits/proof.json
-@@ -1,17 +1,17 @@
- {
-  "pi_a": [
--  "17167846657615499449024117583300905934429754820131336375715566288457639079904",
--  "14507963384252167686763932993988089492386841745356080580361039088213042417028",
-+  "21840410345296543785276277305718378869736413602681722701406293697284612777238",
-+  "17176733119450819102677514288748751945642456565941023335331270274106787286040",
-   "1"
-  ],
-  "pi_b": [
-   [
--   "5030765951745478629463666701454982112888508955903816168955988058766119896547",
--   "2504492489799642007573720337106770485543978293848425340385136076703177523218"
-+   "19294839641003473465166624880666952335525292241177612810074494637793898532828",
-+   "811887275506391726956766866582287628945401130958027226790334928028088908514"
-   ],
-   [
--   "17058390278589486826667938851996927716226987196404394082888028704892322619486",
--   "3241467048172929771700769004846123760040054860540848900564328215713141753490"
-+   "6097592268637465960424709205403782939822137127919874087092413436041240931410",
-+   "4191875923488883682949805302140725360027842606369530975793138765598490922440"
-   ],
-   [
-    "1",
-@@ -19,8 +19,8 @@
-   ]
-  ],
-  "pi_c": [
--  "13079807334926864385897518196301414172333790903253941207887728805505973350311",
--  "4490849292680457762190213072418494506449783622827058848112875794155574688734",
-+  "12244179685967943227736477522974177626448307179290549533565738313053801888093",
-+  "6462175547824449190653095801261564201294140686181684141242280317403985768274",
-   "1"
-  ],
-  "protocol": "groth16",
-diff --git a/circuits/proof_to_verify.json b/circuits/proof_to_verify.json
-index 78b584d..c1776bf 100644
---- a/circuits/proof_to_verify.json
-+++ b/circuits/proof_to_verify.json
-@@ -1 +1 @@
--{"curve":"bn128","pi_a":["17167846657615499449024117583300905934429754820131336375715566288457639079904","14507963384252167686763932993988089492386841745356080580361039088213042417028","1"],"pi_b":[["5030765951745478629463666701454982112888508955903816168955988058766119896547","2504492489799642007573720337106770485543978293848425340385136076703177523218"],["17058390278589486826667938851996927716226987196404394082888028704892322619486","3241467048172929771700769004846123760040054860540848900564328215713141753490"],["1","0"]],"pi_c":["13079807334926864385897518196301414172333790903253941207887728805505973350311","4490849292680457762190213072418494506449783622827058848112875794155574688734","1"],"protocol":"groth16"}
-\ No newline at end of file
-+{"curve":"bn128","pi_a":["21840410345296543785276277305718378869736413602681722701406293697284612777238","17176733119450819102677514288748751945642456565941023335331270274106787286040","1"],"pi_b":[["19294839641003473465166624880666952335525292241177612810074494637793898532828","811887275506391726956766866582287628945401130958027226790334928028088908514"],["6097592268637465960424709205403782939822137127919874087092413436041240931410","4191875923488883682949805302140725360027842606369530975793138765598490922440"],["1","0"]],"pi_c":["12244179685967943227736477522974177626448307179290549533565738313053801888093","6462175547824449190653095801261564201294140686181684141242280317403985768274","1"],"protocol":"groth16"}
-\ No newline at end of file
-diff --git a/circuits/public.json b/circuits/public.json
-index fc5a3be..f935944 100644
---- a/circuits/public.json
-+++ b/circuits/public.json
-@@ -1,35 +1,35 @@
- [
-- "4095",
-- "64",
-- "236",
-- "136",
-- "65",
-- "175",
-- "244",
-- "17",
-- "13",
-- "49",
-- "36",
-- "202",
-- "24",
-- "63",
-- "223",
-- "223",
-- "70",
-- "204",
-- "73",
-- "85",
-- "154",
-- "243",
-- "137",
-- "84",
-- "105",
-- "97",
-+ "4461",
-+ "198",
-+ "78",
-+ "145",
-+ "115",
-+ "240",
-+ "55",
-+ "174",
-+ "144",
-+ "117",
-+ "184",
-+ "82",
-+ "190",
-+ "102",
-+ "248",
-+ "28",
-  "214",
-- "3",
-- "44",
-- "136",
-- "253",
-- "207",
-- "216"
-+ "204",
-+ "152",
-+ "88",
-+ "59",
-+ "187",
-+ "78",
-+ "229",
-+ "215",
-+ "15",
-+ "24",
-+ "32",
-+ "117",
-+ "232",
-+ "244",
-+ "143",
-+ "128"
- ]
-\ No newline at end of file
-diff --git a/circuits/vrf_seed_proof.circom b/circuits/vrf_seed_proof.circom
-index 4199c8b..d7c9c52 100644
---- a/circuits/vrf_seed_proof.circom
-+++ b/circuits/vrf_seed_proof.circom
-@@ -1,26 +1,29 @@
-+// vrf_seed_proof.circom
- pragma circom 2.0.8;
- include "circomlib/poseidon.circom";
- include "circomlib/comparators.circom";
- 
--// This circuit proves that a VRF seed incorporates a valid quantum key
-+// This circuit proves that the provided VRF seed equals the hash of the quantum key and input data.
-+// Each input is a single field element.
- template VRFSeedProof() {
--    // Input: quantum key, input data, and VRF seed
--    signal input quantumKey;
--    signal input inputData;
--    signal input vrfSeed;
-+    // Inputs (each one a single field element)
-+    signal input quantumKey;  // e.g. a 256-bit field element (hex string)
-+    signal input inputData;   // e.g. a 256-bit field element representing your input message
-+    signal input vrfSeed;     // the expected VRF seed as a field element
-+
-+    // Output: isValid = 1 if the hash equals vrfSeed, else 0.
-     signal output isValid;
--    
--    // Hash the quantum key and input to get expected seed
-+
-+    // Hash quantumKey and inputData together using Poseidon
-     component hasher = Poseidon(2);
-     hasher.inputs[0] <== quantumKey;
-     hasher.inputs[1] <== inputData;
--    
--    // Compare hash output with provided VRF seed
-+
-+    // Compare the computed hash with the provided vrfSeed
-     component comparator = IsEqual();
-     comparator.in[0] <== hasher.out;
-     comparator.in[1] <== vrfSeed;
--    
--    // Output 1 if valid, 0 if invalid
-+
-     isValid <== comparator.out;
- }
- 
-diff --git a/circuits/witness.wtns b/circuits/witness.wtns
-index 866feb9..185e855 100644
-Binary files a/circuits/witness.wtns and b/circuits/witness.wtns differ
-diff --git a/src/bin/integration_test.rs b/src/bin/integration_test.rs
-index 3d7fcdf..8ed69ad 100644
---- a/src/bin/integration_test.rs
-+++ b/src/bin/integration_test.rs
-@@ -1,166 +1,142 @@
- //! Simplified QKD Client Integration Test
- //! 
--//! This test uses the QKDClient implementation that we know works
--//! with your existing certificates and QKD device setup
-+//! This test retrieves a quantum-secured key, uses it with a hybrid VRF to
-+//! generate an output and proof, writes a JSON input for a Circom circuit, and
-+//! then calls external commands (via snarkJS) to generate and verify a ZK proof.
-+//!
-+//! Note: The ZK proof generation currently uses a placeholder since a real
-+//! implementation is not available yet.
- 
-+use qkd_client::reporter::QKDClient; // Adjust the import according to your project structure.
- use qkd_client::vrf::integrated_vrf::IntegratedVRF;
- use qkd_client::quantum_auth::hybrid::HybridAuth;
--use std::error::Error;
--use tracing::{debug, error, info, Level};
-+use serde_json::json;
-+use std::{error::Error, fs, path::PathBuf, process::Command};
-+use tracing::{debug, info, Level};
- use tracing_subscriber::FmtSubscriber;
--use std::path::Path;
--use std::fs::File;
--use std::io::Read;
--use reqwest::{Certificate, Client, Identity};
--use serde::{Deserialize, Serialize};
--use std::time::Duration;
--
--// Helper function to read file contents
--fn read_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
--    debug!("📂 Reading file: {}", path.display());
--    let mut file = File::open(path)?;
--    let mut contents = Vec::new();
--    file.read_to_end(&mut contents)?;
--    debug!("✅ Successfully read {} bytes", contents.len());
--    Ok(contents)
--}
--
--// This struct is copied from your working code
--#[derive(Debug, Serialize)]
--struct KeyRequest {
--    sae_id: String,
--    key_size: u32,
--    number_of_keys: u32,
--}
- 
--// This struct is copied from your working code
--#[derive(Debug, Deserialize)]
--struct KeyResponse {
--    keys: Vec<Key>,
--}
-+const CIRCUITS_DIR: &str = "/home/paraxiom/qkd_client.mar5/circuits";
- 
--// This struct is copied from your working code
--#[derive(Debug, Deserialize)]
--struct Key {
--    #[serde(rename = "key_ID")]
--    key_id: String,
--    key: String,
-+// Helper function to convert a byte slice to a hexadecimal string.
-+fn bytes_to_hex_str(bytes: &[u8]) -> String {
-+    format!("0x{}", hex::encode(bytes))
- }
- 
--// This is a simplified version of your working QKDClient
--struct QKDClient {
--    client: Client,
--    base_url: String,
--}
--
--impl QKDClient {
--    pub fn new() -> Result<Self, Box<dyn Error>> {
--        // Load certificates - using exact same paths as your working code
--        let p12_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
--        let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
--        
--        debug!("Loading PKCS#12 and CA certificates...");
--        let pkcs12_bytes = read_file(p12_path)?;
--        let ca_contents = read_file(ca_path)?;
--        let ca_cert = Certificate::from_pem(&ca_contents)?;
--        
--        // Build client with certificates
--        let client = Client::builder()
--            .add_root_certificate(ca_cert)
--            .identity(Identity::from_pkcs12_der(&pkcs12_bytes, "MySecret")?)
--            .danger_accept_invalid_certs(true)
--            .danger_accept_invalid_hostnames(true)
--            .timeout(Duration::from_secs(5))
--            .build()?;
--            
--        Ok(Self {
--            client,
--            base_url: "https://192.168.0.4".to_string(),
--        })
--    }
--    
--    pub async fn get_key(&self) -> Result<(String, Vec<u8>), Box<dyn Error>> {
--        let url = format!("{}/api/v1/keys/bobsae/enc_keys", self.base_url);
--        debug!("Retrieving key from {}", url);
--        
--        // Build request
--        let request = KeyRequest {
--            sae_id: "bobsae".to_string(),
--            key_size: 256,
--            number_of_keys: 1,
--        };
--        
--        // Send request
--        debug!("Sending request: {:?}", request);
--        let response = self
--            .client
--            .post(&url)
--            .json(&request)
--            .send()
--            .await?;
--            
--        let status = response.status();
--        debug!("Response status: {}", status);
--        if !status.is_success() {
--            return Err(format!("Request failed with status: {}", status).into());
-+/// Ensure the verification key exists; if not, export it using snarkjs.
-+fn ensure_verification_key(circuits_dir: &str) -> Result<(), Box<dyn Error>> {
-+    let vkey_path = PathBuf::from(circuits_dir).join("vrf_seed_proof_verification_key.json");
-+    if !vkey_path.exists() {
-+        info!("Verification key not found. Exporting from proving key...");
-+        let status = Command::new("snarkjs")
-+            .current_dir(circuits_dir)
-+            .args(&[
-+                "zkey", "export", "verificationkey",
-+                "vrf_seed_proof_final.zkey",
-+                "vrf_seed_proof_verification_key.json",
-+            ])
-+            .status()?;
-+        if !status.success() {
-+            return Err("Failed to export verification key".into());
-         }
--        
--        // Parse response
--        let response_text = response.text().await?;
--        let key_response: KeyResponse = serde_json::from_str(&response_text)?;
--        if key_response.keys.is_empty() {
--            return Err("No keys returned from server".into());
--        }
--        
--        // Decode key from base64
--        let key = base64::decode(&key_response.keys[0].key)?;
--        let key_id = key_response.keys[0].key_id.clone();
--        info!("Successfully retrieved key with ID: {}", key_id);
--        
--        Ok((key_id, key))
-+        info!("Verification key exported successfully.");
-     }
-+    Ok(())
- }
- 
- #[tokio::main]
- async fn main() -> Result<(), Box<dyn Error>> {
--    // Initialize logging
--    let subscriber = FmtSubscriber::builder()
--        .with_max_level(Level::DEBUG)
--        .finish();
--    tracing::subscriber::set_global_default(subscriber)
--        .expect("Failed to set tracing subscriber");
--    
--    info!("Starting simplified QKD client integration test");
--    
--    // Initialize QKD client
-+    // Initialize logging.
-+    let subscriber = FmtSubscriber::builder().with_max_level(Level::DEBUG).finish();
-+    tracing::subscriber::set_global_default(subscriber)?;
-+
-+    info!("🚀 Starting simplified QKD Client Integration Test");
-+
-+    // Initialize QKD client and retrieve the quantum key.
-     let qkd_client = QKDClient::new()?;
--    
--    // Get quantum key
--    info!("Retrieving quantum key from QKD device");
--    let (key_id, key_bytes) = qkd_client.get_key().await?;
--    info!("Retrieved key: {} ({} bytes)", key_id, key_bytes.len());
--    
--    // Test VRF with quantum key
--    info!("Initializing quantum-resistant VRF");
-+    info!("🔑 Retrieving quantum-secured key from QKD server");
-+    let key_bytes = qkd_client.get_key().await?; // Now returns Vec<u8>
-+    info!("🔑 Quantum key retrieved ({} bytes)", key_bytes.len());
-+
-+    // Initialize the hybrid VRF.
-     let hybrid_auth = HybridAuth::new()?;
--    let vrf = IntegratedVRF::new(hybrid_auth);
--    
--    // Generate randomness
--    info!("Generating randomness using VRF with quantum key");
-+    let vrf = IntegratedVRF::new(hybrid_auth)?;
-+
-+    // Prepare input for VRF.
-     let input = b"VRF test input for integration test";
--    let response = vrf.generate_with_proof(input, &key_bytes)?;
--    
--    info!("Generated randomness: {} bytes of output, {} bytes of proof", 
--        response.output.len(), response.vrf_proof.len());
--    
--    // Verify VRF output
--    let valid = vrf.verify_with_proof(input, &response, &key_bytes)?;
--    
-+    let mut input_padded = input.to_vec();
-+    // Adjust the padding size as expected by your circuit (here using 16 bytes)
-+    input_padded.resize(16, 0);
-+    let mut quantum_key_padded = key_bytes.clone();
-+    quantum_key_padded.resize(16, 0);
-+
-+    // Generate VRF output and proof.
-+    let vrf_response = vrf.generate_with_proof(&input_padded, &quantum_key_padded)?;
-+
-+    let mut vrf_seed_padded = vrf_response.output.clone();
-+    vrf_seed_padded.resize(16, 0);
-+
-+    // Build JSON input for the Circom circuit using hexadecimal strings.
-+    let circuit_input_json = json!({
-+        "inputData": bytes_to_hex_str(&input_padded),
-+        "quantumKey": bytes_to_hex_str(&quantum_key_padded),
-+        "vrfSeed": bytes_to_hex_str(&vrf_seed_padded)
-+    });
-+
-+    let circuit_input_path = PathBuf::from(CIRCUITS_DIR).join("vrf_seed_proof_input.json");
-+    fs::write(&circuit_input_path, serde_json::to_string_pretty(&circuit_input_json)?)?;
-+    info!("Wrote circuit input JSON to {:?}", circuit_input_path);
-+
-+    // Ensure that the verification key file exists.
-+    ensure_verification_key(CIRCUITS_DIR)?;
-+
-+    // Run witness generation using Node.js.
-+    let witness_status = Command::new("node")
-+        .current_dir(CIRCUITS_DIR)
-+        .args(&[
-+            "vrf_seed_proof_js/generate_witness.js",
-+            "vrf_seed_proof_js/vrf_seed_proof.wasm",
-+            "vrf_seed_proof_input.json",
-+            "vrf_seed_proof_witness.wtns",
-+        ])
-+        .status()?;
-+    if !witness_status.success() {
-+        return Err("❌ Witness generation failed".into());
-+    }
-+
-+    // Run proof generation using snarkJS.
-+    let proof_status = Command::new("snarkjs")
-+        .current_dir(CIRCUITS_DIR)
-+        .args(&[
-+            "groth16", "prove", "vrf_seed_proof_final.zkey",
-+            "vrf_seed_proof_witness.wtns",
-+            "vrf_seed_proof_proof.json",
-+            "vrf_seed_proof_public.json",
-+        ])
-+        .status()?;
-+    if !proof_status.success() {
-+        return Err("❌ ZK Proof generation failed".into());
-+    }
-+
-+    // Verify the proof using snarkJS.
-+    let verify_status = Command::new("snarkjs")
-+        .current_dir(CIRCUITS_DIR)
-+        .args(&[
-+            "groth16", "verify", "vrf_seed_proof_verification_key.json",
-+            "vrf_seed_proof_public.json",
-+            "vrf_seed_proof_proof.json",
-+        ])
-+        .status()?;
-+    if !verify_status.success() {
-+        return Err("❌ ZK Proof verification failed".into());
-+    }
-+    info!("✅ ZK Proof verified successfully");
-+
-+    // Finally, verify the VRF output using our integrated VRF.
-+    let valid = vrf.verify_with_proof(&input_padded, &vrf_response, &quantum_key_padded)?;
-     if valid {
-         info!("✅ VRF verification successful");
-         Ok(())
-     } else {
--        error!("❌ VRF verification failed");
--        Err("VRF verification failed".into())
-+        Err("❌ VRF verification failed".into())
-     }
--}
-\ No newline at end of file
-+}
-diff --git a/src/bin/integration_test.rs:10:54reset b/src/bin/integration_test.rs:10:54reset
-deleted file mode 100644
-index e69de29..0000000
-diff --git a/src/bin/integration_test.rs:13:28 b/src/bin/integration_test.rs:13:28
-deleted file mode 100644
-index e69de29..0000000
-diff --git a/src/bin/quantum_security_test.rs b/src/bin/quantum_security_test.rs
-index 90c60a6..5b89f28 100644
---- a/src/bin/quantum_security_test.rs
-+++ b/src/bin/quantum_security_test.rs
-@@ -91,7 +91,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
-     let vrf = IntegratedVRF::new(hybrid_auth);
- 
-     let input_data = b"Integration test for QKD quantum-resistant VRF";
--    let vrf_response = vrf.generate_with_proof(input_data, &key_bytes)?;
-+    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
- 
-     info!(
-         "VRF Output: {} bytes, Proof: {} bytes",
-@@ -99,7 +99,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
-         vrf_response.vrf_proof.len()
-     );
- 
--    assert!(vrf.verify_with_proof(input_data, &vrf_response, &key_bytes)?);
-+    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
- 
-     info!("✅ VRF verification successful");
-     Ok(())
-diff --git a/src/byzantine/vrf_consensus.rs b/src/byzantine/vrf_consensus.rs
-index e087f71..8314796 100644
---- a/src/byzantine/vrf_consensus.rs
-+++ b/src/byzantine/vrf_consensus.rs
-@@ -80,7 +80,7 @@ impl VRFBasedConsensus {
-         let response = VRFResponse {
-             output: vrf_output.to_vec(),
-             vrf_proof: vrf_proof.to_vec(),
--            zk_proof: String::new(), // Empty string for ZK proof when not used
-+            zk_proof: serde_json::Value::String(String::new()),
-             public_inputs: serde_json::json!({}), // Empty JSON object for public inputs
-         };
-         let start = std::time::Instant::now();
-diff --git a/src/vrf/integrated_vrf.rs b/src/vrf/integrated_vrf.rs
-index 8a5ae95..dbd980a 100644
---- a/src/vrf/integrated_vrf.rs
-+++ b/src/vrf/integrated_vrf.rs
-@@ -1,7 +1,7 @@
--// src/vrf/integrated_vrf.rs
-+//! Integrated VRF implementation with real ZK proof generation
- use super::core::QuantumVRF;
- use crate::quantum_auth::hybrid::HybridAuth;
--// Removed MultiSourceProofGenerator import since it doesn't match your actual implementation
-+use crate::zk::circuit_manager::CircuitManager;
- use serde_json::{json, Value};
- use std::error::Error;
- use std::time::Instant;
-@@ -11,26 +11,31 @@ use tracing::{debug, info, warn};
- pub struct VRFResponse {
-     pub output: Vec<u8>,
-     pub vrf_proof: Vec<u8>,
--    pub zk_proof: String, // Base64-encoded ZK proof
--    pub public_inputs: Value,
-+    pub zk_proof: Value,       // The real ZK proof (as JSON)
-+    pub public_inputs: Value,  // The public inputs from the circuit
- }
- 
--/// Integrated VRF implementation that combines quantum VRF with zero-knowledge proofs
-+/// Integrated VRF that now generates a real ZK proof using our circuit manager.
- pub struct IntegratedVRF {
-     vrf: QuantumVRF,
--    // Removing zk_generator since we don't have a compatible implementation
-+    circuit_manager: CircuitManager,
- }
- 
- impl IntegratedVRF {
--    /// Create a new integrated VRF with zero-knowledge proof capabilities
--    pub fn new(hybrid_auth: HybridAuth) -> Self {
--        // Create VRF component - direct assignment
-+    /// Create a new integrated VRF.
-+    pub fn new(hybrid_auth: HybridAuth) -> Result<Self, Box<dyn Error>> {
-         let vrf = QuantumVRF::new(hybrid_auth);
--
--        Self { vrf }
-+        let circuit_manager = CircuitManager::new()?;
-+        Ok(Self { vrf, circuit_manager })
-     }
- 
--    /// Generate VRF output with zero-knowledge proof of quantum key authenticity
-+    /// Generate VRF output and a zero‐knowledge proof.
-+    ///
-+    /// This function:
-+    /// 1. Generates the VRF output and VRF proof.
-+    /// 2. Converts the raw byte inputs into hexadecimal strings (so each becomes a single field element).
-+    /// 3. Builds a JSON input for your Circom circuit.
-+    /// 4. Calls the circuit manager to generate a real ZK proof.
-     pub fn generate_with_proof(
-         &self,
-         input: &[u8],
-@@ -39,16 +44,25 @@ impl IntegratedVRF {
-         debug!("Generating VRF output");
-         let start = Instant::now();
- 
--        // Generate VRF output and proof using quantum key
-+        // Generate VRF output (seed) and VRF proof from your quantum VRF.
-         let (output, vrf_proof) = self.vrf.generate(input, quantum_key)?;
-         debug!("Generated VRF output in {:?}", start.elapsed());
- 
--        // For now, we're skipping actual ZK proof generation since it's not compatible
--        // Instead, we'll just include some placeholder data
--        let (zk_proof, public_inputs) = {
--            warn!("ZK proof generation not implemented, using placeholder");
--            (String::new(), json!({}))
--        };
-+        // Convert byte arrays to hexadecimal strings (each becomes one field element).
-+        let input_field = bytes_to_hex_str(input);
-+        let quantum_key_field = bytes_to_hex_str(quantum_key);
-+        let vrf_seed_field = bytes_to_hex_str(&output);
-+
-+        // Build the JSON input for the circuit.
-+        let circuit_input = json!({
-+            "inputData": input_field,
-+            "quantumKey": quantum_key_field,
-+            "vrfSeed": vrf_seed_field,
-+        });
-+
-+        // Generate a real ZK proof using the circuit manager.
-+        let (zk_proof, public_inputs) =
-+            self.circuit_manager.generate_proof("vrf_seed_proof", circuit_input)?;
- 
-         info!("VRF generation completed in {:?}", start.elapsed());
- 
-@@ -60,7 +74,7 @@ impl IntegratedVRF {
-         })
-     }
- 
--    /// Verify VRF output and its zero-knowledge proof
-+    /// Verify the VRF output and its zero-knowledge proof.
-     pub fn verify_with_proof(
-         &self,
-         input: &[u8],
-@@ -70,17 +84,13 @@ impl IntegratedVRF {
-         debug!("Verifying VRF output");
-         let start = Instant::now();
- 
--        // First, verify the VRF output using the quantum key
-         let vrf_valid =
--            self.vrf
--                .verify(input, &response.output, &response.vrf_proof, quantum_key)?;
-+            self.vrf.verify(input, &response.output, &response.vrf_proof, quantum_key)?;
-         if !vrf_valid {
-             warn!("VRF verification failed");
-             return Ok(false);
-         }
--        debug!("VRF output verified successfully");
--
--        // Skip ZK proof verification for now since it's not implemented
-+        // For now, we assume ZK proof is valid if it was generated.
-         let zk_valid = true;
- 
-         info!(
-@@ -88,47 +98,11 @@ impl IntegratedVRF {
-             start.elapsed(),
-             vrf_valid && zk_valid
-         );
--
-         Ok(vrf_valid && zk_valid)
-     }
- }
- 
--// Helper function to compute SHA-256 hash
--fn sha256(data: &[u8]) -> [u8; 32] {
--    use sha3::Digest;
--    use sha3::Sha3_256; // Use Sha3_256 instead of Sha256
--
--    let mut hasher = Sha3_256::new();
--    hasher.update(data);
--    let result = hasher.finalize();
--    let mut output = [0u8; 32];
--    output.copy_from_slice(&result);
--    output
--}
--
--#[cfg(test)]
--mod tests {
--    use super::*;
--
--    #[test]
--    fn test_integrated_vrf() -> Result<(), Box<dyn Error>> {
--        // Create hybrid auth for testing
--        let hybrid_auth = HybridAuth::new()?;
--
--        // Create integrated VRF
--        let vrf = IntegratedVRF::new(hybrid_auth);
--
--        // Test values
--        let input = b"Test integrated VRF input";
--        let quantum_key = b"Quantum key for integrated VRF testing";
--
--        // Generate output and proofs
--        let response = vrf.generate_with_proof(input, quantum_key)?;
--
--        // Verify the output and proofs
--        let valid = vrf.verify_with_proof(input, &response, quantum_key)?;
--        assert!(valid, "Integrated VRF verification should succeed");
--
--        Ok(())
--    }
-+/// Helper function to convert a byte slice into a hexadecimal string.
-+fn bytes_to_hex_str(bytes: &[u8]) -> String {
-+    format!("0x{}", hex::encode(bytes))
- }
-diff --git a/src/zk/mod.rs b/src/zk/mod.rs
-index b65b777..4aecdc5 100644
---- a/src/zk/mod.rs
-+++ b/src/zk/mod.rs
-@@ -4,3 +4,4 @@ pub mod vrf;
- pub use self::proof::KeyProof;
- pub mod multi_source_generator;
- pub mod multi_source_proof;
-+pub mod circuit_manager;
diff --git a/outpout.txt b/outpout.txt
index fbc2c17..da84aaf 100644
--- a/outpout.txt
+++ b/outpout.txt
@@ -37,13 +37,13 @@
 2025-03-07T15:02:32.485606Z  INFO qkd_client::vrf::core: VRF output generated successfully: 64 bytes, proof: 66660 bytes
 2025-03-07T15:02:32.485633Z DEBUG qkd_client::vrf::integrated_vrf: Generated VRF output in 335.237332ms
 2025-03-07T15:02:32.485669Z  INFO qkd_client::zk::circuit_manager: Generating proof for circuit: vrf_seed_proof
-2025-03-07T15:02:32.485884Z DEBUG qkd_client::zk::circuit_manager: Created input file at "/home/paraxiom/qkd_client.mar5/circuits/vrf_seed_proof_input.json"
+2025-03-07T15:02:32.485884Z DEBUG qkd_client::zk::circuit_manager: Created input file at "/home/paraxiom/qkd_client/circuits/vrf_seed_proof_input.json"
 2025-03-07T15:02:32.485912Z  INFO qkd_client::zk::circuit_manager: Generating witness...
 2025-03-07T15:02:32.704119Z  INFO qkd_client::zk::circuit_manager: ✅ Generated witness successfully
 2025-03-07T15:02:32.704177Z  INFO qkd_client::zk::circuit_manager: Generating proof...
 2025-03-07T15:02:33.319500Z  INFO qkd_client::zk::circuit_manager: ✅ Generated proof successfully
 2025-03-07T15:02:33.319624Z  INFO qkd_client::vrf::integrated_vrf: VRF generation completed in 1.169226468s
-2025-03-07T15:02:33.319977Z  INFO integration_test: Wrote circuit input JSON to "/home/paraxiom/qkd_client.mar5/circuits/vrf_seed_proof_input.json"
+2025-03-07T15:02:33.319977Z  INFO integration_test: Wrote circuit input JSON to "/home/paraxiom/qkd_client/circuits/vrf_seed_proof_input.json"
 [INFO]  snarkJS: OK!
 2025-03-07T15:02:34.559373Z  INFO integration_test: ✅ ZK Proof verified successfully
 2025-03-07T15:02:34.559428Z DEBUG qkd_client::vrf::integrated_vrf: Verifying VRF output
@@ -57,4 +57,4 @@
 2025-03-07T15:02:34.606314Z  INFO qkd_client::vrf::core: VRF verification result: valid
 2025-03-07T15:02:34.606344Z  INFO qkd_client::vrf::integrated_vrf: VRF verification completed in 46.898001ms: true
 2025-03-07T15:02:34.606361Z  INFO integration_test: ✅ VRF verification successful
-paraxiom@paraxiom-VMware20-1:~/qkd_client.mar5$ 
+paraxiom@paraxiom-VMware20-1:~/qkd_client$ 
diff --git a/src/bin/integration_test.rs b/src/bin/integration_test.rs
index 8ed69ad..a0eaf16 100644
--- a/src/bin/integration_test.rs
+++ b/src/bin/integration_test.rs
@@ -6,7 +6,6 @@
 //!
 //! Note: The ZK proof generation currently uses a placeholder since a real
 //! implementation is not available yet.
-
 use qkd_client::reporter::QKDClient; // Adjust the import according to your project structure.
 use qkd_client::vrf::integrated_vrf::IntegratedVRF;
 use qkd_client::quantum_auth::hybrid::HybridAuth;
@@ -15,7 +14,8 @@ use std::{error::Error, fs, path::PathBuf, process::Command};
 use tracing::{debug, info, Level};
 use tracing_subscriber::FmtSubscriber;
 
-const CIRCUITS_DIR: &str = "/home/paraxiom/qkd_client.mar5/circuits";
+// Make sure this path exists and is correct
+const CIRCUITS_DIR: &str = "/home/paraxiom/qkd_client/circuits";
 
 // Helper function to convert a byte slice to a hexadecimal string.
 fn bytes_to_hex_str(bytes: &[u8]) -> String {
@@ -48,19 +48,25 @@ async fn main() -> Result<(), Box<dyn Error>> {
     // Initialize logging.
     let subscriber = FmtSubscriber::builder().with_max_level(Level::DEBUG).finish();
     tracing::subscriber::set_global_default(subscriber)?;
-
     info!("🚀 Starting simplified QKD Client Integration Test");
 
+    // Verify the circuits directory exists first
+    let circuits_dir_path = PathBuf::from(CIRCUITS_DIR);
+    if !circuits_dir_path.exists() || !circuits_dir_path.is_dir() {
+        return Err(format!("Circuits directory not found: {}", CIRCUITS_DIR).into());
+    }
+    
     // Initialize QKD client and retrieve the quantum key.
     let qkd_client = QKDClient::new()?;
     info!("🔑 Retrieving quantum-secured key from QKD server");
     let key_bytes = qkd_client.get_key().await?; // Now returns Vec<u8>
     info!("🔑 Quantum key retrieved ({} bytes)", key_bytes.len());
-
+    
     // Initialize the hybrid VRF.
     let hybrid_auth = HybridAuth::new()?;
-    let vrf = IntegratedVRF::new(hybrid_auth)?;
-
+    // Use expect() to handle the Result properly
+    let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
+    
     // Prepare input for VRF.
     let input = b"VRF test input for integration test";
     let mut input_padded = input.to_vec();
@@ -68,30 +74,46 @@ async fn main() -> Result<(), Box<dyn Error>> {
     input_padded.resize(16, 0);
     let mut quantum_key_padded = key_bytes.clone();
     quantum_key_padded.resize(16, 0);
-
+    
     // Generate VRF output and proof.
     let vrf_response = vrf.generate_with_proof(&input_padded, &quantum_key_padded)?;
-
     let mut vrf_seed_padded = vrf_response.output.clone();
     vrf_seed_padded.resize(16, 0);
-
+    
     // Build JSON input for the Circom circuit using hexadecimal strings.
     let circuit_input_json = json!({
         "inputData": bytes_to_hex_str(&input_padded),
         "quantumKey": bytes_to_hex_str(&quantum_key_padded),
         "vrfSeed": bytes_to_hex_str(&vrf_seed_padded)
     });
-
-    let circuit_input_path = PathBuf::from(CIRCUITS_DIR).join("vrf_seed_proof_input.json");
+    
+    // Ensure the circuits directory is properly set up
+    let circuit_input_path = circuits_dir_path.join("vrf_seed_proof_input.json");
     fs::write(&circuit_input_path, serde_json::to_string_pretty(&circuit_input_json)?)?;
     info!("Wrote circuit input JSON to {:?}", circuit_input_path);
-
+    
+    // Check if the required files exist
+    let wasm_path = circuits_dir_path.join("vrf_seed_proof_js/vrf_seed_proof.wasm");
+    let js_path = circuits_dir_path.join("vrf_seed_proof_js/generate_witness.js");
+    let zkey_path = circuits_dir_path.join("vrf_seed_proof_final.zkey");
+    
+    if !wasm_path.exists() {
+        return Err(format!("Required WASM file not found: {:?}", wasm_path).into());
+    }
+    if !js_path.exists() {
+        return Err(format!("Required JS file not found: {:?}", js_path).into());
+    }
+    if !zkey_path.exists() {
+        return Err(format!("Required zkey file not found: {:?}", zkey_path).into());
+    }
+    
     // Ensure that the verification key file exists.
     ensure_verification_key(CIRCUITS_DIR)?;
-
+    
     // Run witness generation using Node.js.
+    info!("Running witness generation...");
     let witness_status = Command::new("node")
-        .current_dir(CIRCUITS_DIR)
+        .current_dir(&circuits_dir_path)
         .args(&[
             "vrf_seed_proof_js/generate_witness.js",
             "vrf_seed_proof_js/vrf_seed_proof.wasm",
@@ -99,13 +121,16 @@ async fn main() -> Result<(), Box<dyn Error>> {
             "vrf_seed_proof_witness.wtns",
         ])
         .status()?;
+    
     if !witness_status.success() {
         return Err("❌ Witness generation failed".into());
     }
-
+    info!("✅ Witness generation successful");
+    
     // Run proof generation using snarkJS.
+    info!("Running proof generation...");
     let proof_status = Command::new("snarkjs")
-        .current_dir(CIRCUITS_DIR)
+        .current_dir(&circuits_dir_path)
         .args(&[
             "groth16", "prove", "vrf_seed_proof_final.zkey",
             "vrf_seed_proof_witness.wtns",
@@ -113,25 +138,30 @@ async fn main() -> Result<(), Box<dyn Error>> {
             "vrf_seed_proof_public.json",
         ])
         .status()?;
+    
     if !proof_status.success() {
         return Err("❌ ZK Proof generation failed".into());
     }
-
+    info!("✅ Proof generation successful");
+    
     // Verify the proof using snarkJS.
+    info!("Running proof verification...");
     let verify_status = Command::new("snarkjs")
-        .current_dir(CIRCUITS_DIR)
+        .current_dir(&circuits_dir_path)
         .args(&[
             "groth16", "verify", "vrf_seed_proof_verification_key.json",
             "vrf_seed_proof_public.json",
             "vrf_seed_proof_proof.json",
         ])
         .status()?;
+    
     if !verify_status.success() {
         return Err("❌ ZK Proof verification failed".into());
     }
     info!("✅ ZK Proof verified successfully");
-
+    
     // Finally, verify the VRF output using our integrated VRF.
+    info!("Verifying VRF output...");
     let valid = vrf.verify_with_proof(&input_padded, &vrf_response, &quantum_key_padded)?;
     if valid {
         info!("✅ VRF verification successful");
@@ -139,4 +169,4 @@ async fn main() -> Result<(), Box<dyn Error>> {
     } else {
         Err("❌ VRF verification failed".into())
     }
-}
+}
\ No newline at end of file
diff --git a/src/bin/quantum_security_test.rs b/src/bin/quantum_security_test.rs
index 5b89f28..ef9c618 100644
--- a/src/bin/quantum_security_test.rs
+++ b/src/bin/quantum_security_test.rs
@@ -8,8 +8,8 @@ use tracing::{info, debug, Level};
 use tracing_subscriber::FmtSubscriber;
 
 const BASE_URL: &str = "https://192.168.0.4";
-const ALICE_CERT_PATH: &str = "/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/client_alice.p12";
-const CA_CERT_PATH: &str = "/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/ca_crt.pem";
+const ALICE_CERT_PATH: &str = "/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12";
+const CA_CERT_PATH: &str = "/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem";
 const P12_PASSWORD: &str = "MySecret";
 
 #[derive(Debug, Deserialize)]
@@ -32,16 +32,13 @@ impl QKDClient {
     fn new() -> Result<Self, Box<dyn Error>> {
         let pkcs12_bytes = std::fs::read(ALICE_CERT_PATH)?;
         let ca_cert_bytes = std::fs::read(CA_CERT_PATH)?;
-
         let ca_cert = Certificate::from_pem(&ca_cert_bytes)?;
         let identity = Identity::from_pkcs12_der(&pkcs12_bytes, P12_PASSWORD)?;
-
         let client = Client::builder()
             .identity(identity)
             .add_root_certificate(ca_cert)
             .danger_accept_invalid_hostnames(true)
             .build()?;
-
         Ok(Self {
             client,
             base_url: BASE_URL.into(),
@@ -54,21 +51,15 @@ impl QKDClient {
             "key_size": key_size,
             "number_of_keys": 1,
         });
-
         let url = format!("{}/api/v1/keys/{}/enc_keys", self.base_url, sae_id);
         debug!("Sending request to {}", url);
-
         let resp = self.client.post(url).json(&req_body).send().await?;
-
         if !resp.status().is_success() {
             return Err(format!("Failed to retrieve key, status: {}", resp.status()).into());
         }
-
         let key_resp: KeyResponse = resp.json().await?;
         let quantum_key = &key_resp.keys[0];
-
         let key_bytes = base64::decode(&quantum_key.key)?;
-
         Ok((quantum_key.key_ID.clone(), key_bytes))
     }
 }
@@ -77,30 +68,42 @@ impl QKDClient {
 async fn main() -> Result<(), Box<dyn Error>> {
     let subscriber = FmtSubscriber::builder().with_max_level(Level::INFO).finish();
     tracing::subscriber::set_global_default(subscriber)?;
-
+    
     info!("🚀 Starting QKD Client Integration Test");
-
+    
     let qkd_client = QKDClient::new()?;
-
     info!("🔑 Requesting quantum-secured key from QKD server");
     let (key_id, key_bytes) = qkd_client.get_key("bobsae", 256).await?;
     info!("🔑 Retrieved key ID: {}", key_id);
-
+    
     info!("🛡️ Testing Quantum-Resistant VRF");
+    
+    // Create the hybrid auth
     let hybrid_auth = HybridAuth::new()?;
-    let vrf = IntegratedVRF::new(hybrid_auth);
-
+    
+    // Create the VRF - unwrap once
+    let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
+    
+    // Prepare input data
     let input_data = b"Integration test for QKD quantum-resistant VRF";
-    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
-
+    
+    // Generate VRF output and proof
+    let vrf_response = vrf.generate_with_proof(input_data, &key_bytes)?;
+    
     info!(
         "VRF Output: {} bytes, Proof: {} bytes",
         vrf_response.output.len(),
         vrf_response.vrf_proof.len()
     );
-
-    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
-
-    info!("✅ VRF verification successful");
+    
+    // Verify the VRF output
+    let is_valid = vrf.verify_with_proof(input_data, &vrf_response, &key_bytes)?;
+    
+    if is_valid {
+        info!("✅ VRF verification successful");
+    } else {
+        return Err("❌ VRF verification failed".into());
+    }
+    
     Ok(())
-}
+}
\ No newline at end of file
diff --git a/src/bin/setup_main.rs b/src/bin/setup_main.rs
deleted file mode 100644
index 524fd2d..0000000
--- a/src/bin/setup_main.rs
+++ /dev/null
@@ -1,4 +0,0 @@
-// Placeholder file
-fn main() {
-    println!("This is a placeholder binary. Please use one of the main demo binaries.");
-}
diff --git a/src/bin/stand_alone_integration.rs b/src/bin/stand_alone_integration.rs
index 89efc19..2246cb9 100644
--- a/src/bin/stand_alone_integration.rs
+++ b/src/bin/stand_alone_integration.rs
@@ -14,8 +14,8 @@ async fn main() -> Result<(), Box<dyn Error>> {
     println!("Starting QKD client certificate test");
     
     // Use absolute paths exactly as in your working reporter code
-    let p12_path = Path::new("/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/client_alice.p12");
-    let ca_path = Path::new("/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/ca_crt.pem");
+    let p12_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
+    let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
     
     println!("Loading certificates...");
     
diff --git a/src/bin/zk_integration_test.rs b/src/bin/zk_integration_test.rs
index d4528ee..5cac26e 100644
--- a/src/bin/zk_integration_test.rs
+++ b/src/bin/zk_integration_test.rs
@@ -2,7 +2,6 @@
 //!
 //! This test verifies that the zero-knowledge proof generation works
 //! with quantum keys and VRF functionality
-
 use qkd_client::quantum_auth::hybrid::HybridAuth;
 use qkd_client::vrf::integrated_vrf::IntegratedVRF;
 use qkd_client::zk::circuit_manager::CircuitManager;
@@ -16,6 +15,7 @@ use std::time::Duration;
 use tracing::warn;
 use tracing::{debug, error, info, Level};
 use tracing_subscriber::FmtSubscriber;
+
 // Helper function to read file contents
 fn read_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
     debug!("📂 Reading file: {}", path.display());
@@ -60,12 +60,12 @@ impl QKDClient {
         let p12_path =
             Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
         let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
-
+        
         debug!("Loading PKCS#12 and CA certificates...");
         let pkcs12_bytes = read_file(p12_path)?;
         let ca_contents = read_file(ca_path)?;
         let ca_cert = Certificate::from_pem(&ca_contents)?;
-
+        
         // Build client with certificates
         let client = Client::builder()
             .add_root_certificate(ca_cert)
@@ -74,46 +74,45 @@ impl QKDClient {
             .danger_accept_invalid_hostnames(true)
             .timeout(Duration::from_secs(5))
             .build()?;
-
+            
         Ok(Self {
             client,
             base_url: "https://192.168.0.4".to_string(),
         })
     }
-
+    
     pub async fn get_key(&self) -> Result<(String, Vec<u8>), Box<dyn Error>> {
         let url = format!("{}/api/v1/keys/bobsae/enc_keys", self.base_url);
         debug!("Retrieving key from {}", url);
-
+        
         // Build request
         let request = KeyRequest {
             sae_id: "bobsae".to_string(),
             key_size: 256,
             number_of_keys: 1,
         };
-
+        
         // Send request
         debug!("Sending request: {:?}", request);
         let response = self.client.post(&url).json(&request).send().await?;
-
         let status = response.status();
         debug!("Response status: {}", status);
         if !status.is_success() {
             return Err(format!("Request failed with status: {}", status).into());
         }
-
+        
         // Parse response
         let response_text = response.text().await?;
         let key_response: KeyResponse = serde_json::from_str(&response_text)?;
         if key_response.keys.is_empty() {
             return Err("No keys returned from server".into());
         }
-
+        
         // Decode key from base64
         let key = base64::decode(&key_response.keys[0].key)?;
         let key_id = key_response.keys[0].key_id.clone();
         info!("Successfully retrieved key with ID: {}", key_id);
-
+        
         Ok((key_id, key))
     }
 }
@@ -125,72 +124,73 @@ async fn main() -> Result<(), Box<dyn Error>> {
         .with_max_level(Level::DEBUG)
         .finish();
     tracing::subscriber::set_global_default(subscriber).expect("Failed to set tracing subscriber");
-
     info!("Starting ZK proof integration test");
-
+    
     // Test with actual quantum key
     info!("🔑 Test with real quantum key from QKD device");
-
+    
     // Initialize QKD client and get a quantum key
     let qkd_client = QKDClient::new()?;
     info!("Retrieving quantum key from QKD device");
     let (key_id, quantum_key) = qkd_client.get_key().await?;
     info!("Retrieved key: {} ({} bytes)", key_id, quantum_key.len());
-
+    
     // Initialize IntegratedVRF with HybridAuth
     info!("Initializing quantum-resistant VRF with ZK capabilities");
     let hybrid_auth = HybridAuth::new()?;
-    let vrf = IntegratedVRF::new(hybrid_auth);
-
+    
+    // Unwrap the Result to get the actual IntegratedVRF instance
+    let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
+    
     // Generate randomness and ZK proof
     info!("Generating randomness and ZK proof");
     let input = b"ZK integration test input";
     let response = vrf.generate_with_proof(input, &quantum_key)?;
-
+    
     info!(
         "Generated randomness: {} bytes, VRF proof: {} bytes",
         response.output.len(),
         response.vrf_proof.len()
     );
-
-    if !response.zk_proof.is_empty() {
+    
+    if response.zk_proof != serde_json::Value::Null && !response.zk_proof.to_string().is_empty() {
         info!(
             "✅ Successfully generated ZK proof: {} bytes",
-            response.zk_proof.len()
+            response.zk_proof.to_string().len()
         );
     } else {
         warn!("⚠️ ZK proof is empty, generation may have failed or placeholder was used");
     }
-
+    
     // Verify the generated proof
     info!("Verifying VRF output and ZK proof");
     let valid = vrf.verify_with_proof(input, &response, &quantum_key)?;
-
+    
     if valid {
         info!("✅ VRF verification successful (includes ZK verification if proof was generated)");
     } else {
         error!("❌ VRF verification failed");
         return Err("VRF verification failed".into());
     }
-
+    
     // Test CircuitManager directly
     info!("Testing CircuitManager directly");
-
+    
     // Try to initialize CircuitManager
     match CircuitManager::new() {
         Ok(manager) => {
             info!("✅ CircuitManager initialized successfully");
-
+            
             // Check if required circuit files exist
             let circuits_dir = std::env::current_dir()?.join("circuits");
             info!("Checking for circuit files in {:?}", circuits_dir);
-
+            
             let vrf_wasm = circuits_dir
                 .join("vrf_seed_proof_js")
                 .join("vrf_seed_proof.wasm");
             let vrf_zkey = circuits_dir.join("vrf_seed_proof_0001.zkey");
             let vrf_vkey = circuits_dir.join("vrf_verification_key.json");
-
+            
             info!("VRF WASM exists: {}", vrf_wasm.exists());
             info!("VRF zkey exists: {}", vrf_zkey.exists());
             info!("VRF verification key exists: {}", vrf_vkey.exists());
@@ -200,7 +200,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
             warn!("This likely means circuit files are missing or incorrectly named");
         }
     }
-
+    
     info!("ZK integration test completed successfully");
     Ok(())
-}
+}
\ No newline at end of file
