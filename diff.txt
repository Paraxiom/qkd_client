diff --git a/analyse,sh b/analyse,sh
deleted file mode 100644
index ec5825f..0000000
--- a/analyse,sh
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/bin/bash
-# Script to concatenate relevant ZK implementation files for analysis
-
-# Create output file
-output_file="zk_implementation_analysis.txt"
-echo "# ZK Implementation Analysis" > $output_file
-echo "Generated on $(date)" >> $output_file
-echo "" >> $output_file
-
-# Function to append a file with a header
-append_file() {
-    if [ -f "$1" ]; then
-        echo -e "\n\n## File: $1\n" >> $output_file
-        echo '```' >> $output_file
-        cat "$1" >> $output_file
-        echo '```' >> $output_file
-        echo "Added $1 to analysis"
-    else
-        echo "Warning: File $1 not found"
-    fi
-}
-
-# VRF implementation files (likely containing the warning)
-echo "### VRF Implementation Files" >> $output_file
-append_file "src/vrf/integrated_vrf.rs"
-append_file "src/vrf/core.rs"
-
-# ZK proof related files
-echo "### ZK Proof Files" >> $output_file
-append_file "src/zk/mod.rs"
-append_file "src/zk/proof_generator.rs"
-append_file "src/zk/multi_source_generator.rs"
-append_file "src/zk/multi_source_proof.rs"
-
-# Circuit definitions
-echo "### Circuit Definitions" >> $output_file
-append_file "circuits/vrf_seed_proof.circom"
-append_file "circuits/multi_source_key.circom"
-
-# Check for any ZK-related utilities
-echo "### ZK Utilities" >> $output_file
-append_file "src/utils/zk_utils.rs"
-append_file "src/zk/circuit_utils.rs"
-
-echo "Analysis file created: $output_file"
diff --git a/analyse.sh b/analyse.sh
deleted file mode 100644
index ec5825f..0000000
--- a/analyse.sh
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/bin/bash
-# Script to concatenate relevant ZK implementation files for analysis
-
-# Create output file
-output_file="zk_implementation_analysis.txt"
-echo "# ZK Implementation Analysis" > $output_file
-echo "Generated on $(date)" >> $output_file
-echo "" >> $output_file
-
-# Function to append a file with a header
-append_file() {
-    if [ -f "$1" ]; then
-        echo -e "\n\n## File: $1\n" >> $output_file
-        echo '```' >> $output_file
-        cat "$1" >> $output_file
-        echo '```' >> $output_file
-        echo "Added $1 to analysis"
-    else
-        echo "Warning: File $1 not found"
-    fi
-}
-
-# VRF implementation files (likely containing the warning)
-echo "### VRF Implementation Files" >> $output_file
-append_file "src/vrf/integrated_vrf.rs"
-append_file "src/vrf/core.rs"
-
-# ZK proof related files
-echo "### ZK Proof Files" >> $output_file
-append_file "src/zk/mod.rs"
-append_file "src/zk/proof_generator.rs"
-append_file "src/zk/multi_source_generator.rs"
-append_file "src/zk/multi_source_proof.rs"
-
-# Circuit definitions
-echo "### Circuit Definitions" >> $output_file
-append_file "circuits/vrf_seed_proof.circom"
-append_file "circuits/multi_source_key.circom"
-
-# Check for any ZK-related utilities
-echo "### ZK Utilities" >> $output_file
-append_file "src/utils/zk_utils.rs"
-append_file "src/zk/circuit_utils.rs"
-
-echo "Analysis file created: $output_file"
diff --git a/circuits/input.json b/circuits/input.json
index a873371..cbe8ad2 100644
--- a/circuits/input.json
+++ b/circuits/input.json
@@ -1 +1 @@
-{"key":[198,78,145,115,240,55,174,144,117,184,82,190,102,248,28,214,204,152,88,59,187,78,229,215,15,24,32,117,232,244,143,128]}
\ No newline at end of file
+{"key":[17,230,106,143,87,235,241,191,4,234,28,94,230,230,201,208,204,213,162,198,178,77,28,130,194,183,127,114,137,107,111,252]}
\ No newline at end of file
diff --git a/circuits/proof.json b/circuits/proof.json
index 1c489d4..c4bb187 100644
--- a/circuits/proof.json
+++ b/circuits/proof.json
@@ -1,17 +1,17 @@
 {
  "pi_a": [
-  "21840410345296543785276277305718378869736413602681722701406293697284612777238",
-  "17176733119450819102677514288748751945642456565941023335331270274106787286040",
+  "769990505877505704063115281391517472544424150780875333636001196945261624274",
+  "5390288538263473524094622575785115668623048313346713928941132344411465260342",
   "1"
  ],
  "pi_b": [
   [
-   "19294839641003473465166624880666952335525292241177612810074494637793898532828",
-   "811887275506391726956766866582287628945401130958027226790334928028088908514"
+   "17427815048719002399247501102282721815971049908238905073577700367576522864138",
+   "4810277826807183609005147036647546473258186407777277805637930753679741316371"
   ],
   [
-   "6097592268637465960424709205403782939822137127919874087092413436041240931410",
-   "4191875923488883682949805302140725360027842606369530975793138765598490922440"
+   "13373576437431309766305674212166319649502294276869553989523593502991723400746",
+   "815856334070815127882676239491920024258298837513838484052257657946945057867"
   ],
   [
    "1",
@@ -19,8 +19,8 @@
   ]
  ],
  "pi_c": [
-  "12244179685967943227736477522974177626448307179290549533565738313053801888093",
-  "6462175547824449190653095801261564201294140686181684141242280317403985768274",
+  "20212349090233440625729525754899354778761095179791280345024274882745342657424",
+  "9292878765085954940765059388752436984654416479231079330021530557681240289941",
   "1"
  ],
  "protocol": "groth16",
diff --git a/circuits/proof_to_verify.json b/circuits/proof_to_verify.json
index c1776bf..ac0e9d0 100644
--- a/circuits/proof_to_verify.json
+++ b/circuits/proof_to_verify.json
@@ -1 +1 @@
-{"curve":"bn128","pi_a":["21840410345296543785276277305718378869736413602681722701406293697284612777238","17176733119450819102677514288748751945642456565941023335331270274106787286040","1"],"pi_b":[["19294839641003473465166624880666952335525292241177612810074494637793898532828","811887275506391726956766866582287628945401130958027226790334928028088908514"],["6097592268637465960424709205403782939822137127919874087092413436041240931410","4191875923488883682949805302140725360027842606369530975793138765598490922440"],["1","0"]],"pi_c":["12244179685967943227736477522974177626448307179290549533565738313053801888093","6462175547824449190653095801261564201294140686181684141242280317403985768274","1"],"protocol":"groth16"}
\ No newline at end of file
+{"curve":"bn128","pi_a":["769990505877505704063115281391517472544424150780875333636001196945261624274","5390288538263473524094622575785115668623048313346713928941132344411465260342","1"],"pi_b":[["17427815048719002399247501102282721815971049908238905073577700367576522864138","4810277826807183609005147036647546473258186407777277805637930753679741316371"],["13373576437431309766305674212166319649502294276869553989523593502991723400746","815856334070815127882676239491920024258298837513838484052257657946945057867"],["1","0"]],"pi_c":["20212349090233440625729525754899354778761095179791280345024274882745342657424","9292878765085954940765059388752436984654416479231079330021530557681240289941","1"],"protocol":"groth16"}
\ No newline at end of file
diff --git a/circuits/public.json b/circuits/public.json
index f935944..86ab212 100644
--- a/circuits/public.json
+++ b/circuits/public.json
@@ -1,35 +1,35 @@
 [
- "4461",
- "198",
- "78",
- "145",
- "115",
- "240",
- "55",
- "174",
- "144",
- "117",
- "184",
- "82",
- "190",
- "102",
- "248",
+ "4894",
+ "17",
+ "230",
+ "106",
+ "143",
+ "87",
+ "235",
+ "241",
+ "191",
+ "4",
+ "234",
  "28",
- "214",
+ "94",
+ "230",
+ "230",
+ "201",
+ "208",
  "204",
- "152",
- "88",
- "59",
- "187",
- "78",
- "229",
- "215",
- "15",
- "24",
- "32",
- "117",
- "232",
- "244",
- "143",
- "128"
+ "213",
+ "162",
+ "198",
+ "178",
+ "77",
+ "28",
+ "130",
+ "194",
+ "183",
+ "127",
+ "114",
+ "137",
+ "107",
+ "111",
+ "252"
 ]
\ No newline at end of file
diff --git a/circuits/vrf_seed_proof_input.json b/circuits/vrf_seed_proof_input.json
index cfe5b76..687443f 100644
--- a/circuits/vrf_seed_proof_input.json
+++ b/circuits/vrf_seed_proof_input.json
@@ -1,5 +1,5 @@
 {
   "inputData": "0x6c65616465722d73656c656374696f6e2d726f756e642d31",
   "quantumKey": "0x0102030405060708090a0b0c0d0e0f10",
-  "vrfSeed": "0x762e08138bb9bc96d4c19096ddc01f040ffa0ee9fc7f2c1ec60b1ec7b7e5dbd2953e54110f548b85aacd66c2571ced8f79e55f8bdcdb5d9890ec5c606d325b1e"
+  "vrfSeed": "0x203e018a6db5bc9872500b8584387f2a087a0988baa7fdee05a95a142bb91f1462a663302f475d0880976032c977af7a48b121b5b8ecd432ce002d5820eb5c1a"
 }
\ No newline at end of file
diff --git a/circuits/vrf_seed_proof_proof.json b/circuits/vrf_seed_proof_proof.json
index 3734613..e65f496 100644
--- a/circuits/vrf_seed_proof_proof.json
+++ b/circuits/vrf_seed_proof_proof.json
@@ -1,17 +1,17 @@
 {
  "pi_a": [
-  "1197951790413255176607110286098598059734225022906712047697984693651660911565",
-  "904505904628915694439485874029463313591554549406155710085537389029855314665",
+  "12989108924204135263840757283362735307567713676152992251814040892996110969296",
+  "10035716342200825779866288649662027869141919506841186694569980013378885535978",
   "1"
  ],
  "pi_b": [
   [
-   "5509149699156825809626663491599698484806582847262202110856688270345223678423",
-   "17945193574507569217201058699137414154063448003500030583161085319289597886041"
+   "1112113909675873154784232693244280682226669245801401590762451565135764547940",
+   "9073796959099729287022896911389298378481001382167764865822583074231070148971"
   ],
   [
-   "18154466004178692928736060458445222228276402565615114956066850159910570319479",
-   "1096665165979052258070737192933137448360641048383246238799187310451712411590"
+   "21626586191735560732065871545717509338082090270876503681230929065175239346317",
+   "13322550285933753396285608980102059239007307919157864136010243042819968958822"
   ],
   [
    "1",
@@ -19,8 +19,8 @@
   ]
  ],
  "pi_c": [
-  "18629354999136449022919636444817852754159201397283238617434008970323253447459",
-  "17062508737217164980717111321189357013294966003932258470452725213243971414754",
+  "14119044588863445576519131319335195311726959178091456819858355622053516457302",
+  "15549477060401742767973019219559334399338895672981477661074479129499596636869",
   "1"
  ],
  "protocol": "groth16",
diff --git a/circuits/vrf_seed_proof_witness.wtns b/circuits/vrf_seed_proof_witness.wtns
index fa616fa..f683cdd 100644
Binary files a/circuits/vrf_seed_proof_witness.wtns and b/circuits/vrf_seed_proof_witness.wtns differ
diff --git a/circuits/witness.wtns b/circuits/witness.wtns
index 185e855..6be95a2 100644
Binary files a/circuits/witness.wtns and b/circuits/witness.wtns differ
diff --git a/diff.txt b/diff.txt
index 02f22a3..177c5de 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,1283 +0,0 @@
-diff --git a/Cargo.toml b/Cargo.toml
-index e7dd6b6..24dd8ef 100644
---- a/Cargo.toml
-+++ b/Cargo.toml
-@@ -11,9 +11,7 @@ path = "src/lib.rs"
- name = "qkd_client"
- path = "src/main.rs"
- 
--[[bin]]
--name = "setup_main"
--path = "src/bin/setup_main.rs"
-+
- 
- [dependencies]
- # Arkworks base
-diff --git a/circuits/vrf_seed_proof_input.json b/circuits/vrf_seed_proof_input.json
-index ee68634..ac6711b 100644
---- a/circuits/vrf_seed_proof_input.json
-+++ b/circuits/vrf_seed_proof_input.json
-@@ -1,5 +1,5 @@
- {
--  "inputData": "0x565246207465737420696e7075742066",
--  "quantumKey": "0x716334450d70fa1aaf76e8ff2f7af9e6",
--  "vrfSeed": "0xe755a8db8ecb11a9589c630d7bce6fac"
-+  "inputData": "0x496e746567726174696f6e207465737420666f7220514b44207175616e74756d2d726573697374616e7420565246",
-+  "quantumKey": "0xacb831d480a51a808f3613adf071da3c14122c59c37452a657b5369977c64772",
-+  "vrfSeed": "0x2f24938bffe144121bb1821ca91673343be926d06372b8c2a4bd1cb8aa238eab8bb4330c280b699981e3bbd970f6f8fa9c1fbf81ebdd0c64de49b7f21bbe6e1b"
- }
-\ No newline at end of file
-diff --git a/circuits/vrf_seed_proof_proof.json b/circuits/vrf_seed_proof_proof.json
-index 636fff8..650726e 100644
---- a/circuits/vrf_seed_proof_proof.json
-+++ b/circuits/vrf_seed_proof_proof.json
-@@ -1,17 +1,17 @@
- {
-  "pi_a": [
--  "6549541717038800044573622964669335740428569585633626404583369603804348359539",
--  "10336046677882615847744072662209419948635854526365204409465820995143402510564",
-+  "1937061703663816248338232570703638454555425365690035865041594443628848454821",
-+  "20097682317821185028232458431737810950071927220994414724656595701429957650733",
-   "1"
-  ],
-  "pi_b": [
-   [
--   "7678945908302714824938083206944826534843216005626975090233913804580847323385",
--   "19096752070834345893716300089491478117505927031424272484876837269256237073491"
-+   "13041577429027539071081802806457148521748171512349577895649492297352790634091",
-+   "9104289294293145151435387652283702669244740202278947725282577663359297819169"
-   ],
-   [
--   "10597584531710061324588356990635705298130605643497956238308418192478177192992",
--   "19354828864930103121186918974715461489153603219319808757523047221565840020342"
-+   "10298364342610562203068532455847447114431308247281342281954110917300887790295",
-+   "14502339859359867349508031178843922716288857260876669572322544697382927173414"
-   ],
-   [
-    "1",
-@@ -19,8 +19,8 @@
-   ]
-  ],
-  "pi_c": [
--  "10342810298443245430522936796307238057539905801289064705375270165437116517746",
--  "6005869275897487482081055586977664521864049997709388531568822681431926680887",
-+  "7130651377037665150455168465830879648921301937751031438414603017767993652519",
-+  "7426517879590819824447837185707421821451474964076650072166545352636158481611",
-   "1"
-  ],
-  "protocol": "groth16",
-diff --git a/circuits/vrf_seed_proof_witness.wtns b/circuits/vrf_seed_proof_witness.wtns
-index f18f47a..e1f4274 100644
-Binary files a/circuits/vrf_seed_proof_witness.wtns and b/circuits/vrf_seed_proof_witness.wtns differ
-diff --git a/diff.txt b/diff.txt
-index b1ad419..e69de29 100644
---- a/diff.txt
-+++ b/diff.txt
-@@ -1,687 +0,0 @@
--diff --git a/circuits/input.json b/circuits/input.json
--index 41ebc44..a873371 100644
----- a/circuits/input.json
--+++ b/circuits/input.json
--@@ -1 +1 @@
---{"key":[64,236,136,65,175,244,17,13,49,36,202,24,63,223,223,70,204,73,85,154,243,137,84,105,97,214,3,44,136,253,207,216]}
--\ No newline at end of file
--+{"key":[198,78,145,115,240,55,174,144,117,184,82,190,102,248,28,214,204,152,88,59,187,78,229,215,15,24,32,117,232,244,143,128]}
--\ No newline at end of file
--diff --git a/circuits/proof.json b/circuits/proof.json
--index f3d54e9..1c489d4 100644
----- a/circuits/proof.json
--+++ b/circuits/proof.json
--@@ -1,17 +1,17 @@
-- {
--  "pi_a": [
---  "17167846657615499449024117583300905934429754820131336375715566288457639079904",
---  "14507963384252167686763932993988089492386841745356080580361039088213042417028",
--+  "21840410345296543785276277305718378869736413602681722701406293697284612777238",
--+  "17176733119450819102677514288748751945642456565941023335331270274106787286040",
--   "1"
--  ],
--  "pi_b": [
--   [
---   "5030765951745478629463666701454982112888508955903816168955988058766119896547",
---   "2504492489799642007573720337106770485543978293848425340385136076703177523218"
--+   "19294839641003473465166624880666952335525292241177612810074494637793898532828",
--+   "811887275506391726956766866582287628945401130958027226790334928028088908514"
--   ],
--   [
---   "17058390278589486826667938851996927716226987196404394082888028704892322619486",
---   "3241467048172929771700769004846123760040054860540848900564328215713141753490"
--+   "6097592268637465960424709205403782939822137127919874087092413436041240931410",
--+   "4191875923488883682949805302140725360027842606369530975793138765598490922440"
--   ],
--   [
--    "1",
--@@ -19,8 +19,8 @@
--   ]
--  ],
--  "pi_c": [
---  "13079807334926864385897518196301414172333790903253941207887728805505973350311",
---  "4490849292680457762190213072418494506449783622827058848112875794155574688734",
--+  "12244179685967943227736477522974177626448307179290549533565738313053801888093",
--+  "6462175547824449190653095801261564201294140686181684141242280317403985768274",
--   "1"
--  ],
--  "protocol": "groth16",
--diff --git a/circuits/proof_to_verify.json b/circuits/proof_to_verify.json
--index 78b584d..c1776bf 100644
----- a/circuits/proof_to_verify.json
--+++ b/circuits/proof_to_verify.json
--@@ -1 +1 @@
---{"curve":"bn128","pi_a":["17167846657615499449024117583300905934429754820131336375715566288457639079904","14507963384252167686763932993988089492386841745356080580361039088213042417028","1"],"pi_b":[["5030765951745478629463666701454982112888508955903816168955988058766119896547","2504492489799642007573720337106770485543978293848425340385136076703177523218"],["17058390278589486826667938851996927716226987196404394082888028704892322619486","3241467048172929771700769004846123760040054860540848900564328215713141753490"],["1","0"]],"pi_c":["13079807334926864385897518196301414172333790903253941207887728805505973350311","4490849292680457762190213072418494506449783622827058848112875794155574688734","1"],"protocol":"groth16"}
--\ No newline at end of file
--+{"curve":"bn128","pi_a":["21840410345296543785276277305718378869736413602681722701406293697284612777238","17176733119450819102677514288748751945642456565941023335331270274106787286040","1"],"pi_b":[["19294839641003473465166624880666952335525292241177612810074494637793898532828","811887275506391726956766866582287628945401130958027226790334928028088908514"],["6097592268637465960424709205403782939822137127919874087092413436041240931410","4191875923488883682949805302140725360027842606369530975793138765598490922440"],["1","0"]],"pi_c":["12244179685967943227736477522974177626448307179290549533565738313053801888093","6462175547824449190653095801261564201294140686181684141242280317403985768274","1"],"protocol":"groth16"}
--\ No newline at end of file
--diff --git a/circuits/public.json b/circuits/public.json
--index fc5a3be..f935944 100644
----- a/circuits/public.json
--+++ b/circuits/public.json
--@@ -1,35 +1,35 @@
-- [
--- "4095",
--- "64",
--- "236",
--- "136",
--- "65",
--- "175",
--- "244",
--- "17",
--- "13",
--- "49",
--- "36",
--- "202",
--- "24",
--- "63",
--- "223",
--- "223",
--- "70",
--- "204",
--- "73",
--- "85",
--- "154",
--- "243",
--- "137",
--- "84",
--- "105",
--- "97",
--+ "4461",
--+ "198",
--+ "78",
--+ "145",
--+ "115",
--+ "240",
--+ "55",
--+ "174",
--+ "144",
--+ "117",
--+ "184",
--+ "82",
--+ "190",
--+ "102",
--+ "248",
--+ "28",
--  "214",
--- "3",
--- "44",
--- "136",
--- "253",
--- "207",
--- "216"
--+ "204",
--+ "152",
--+ "88",
--+ "59",
--+ "187",
--+ "78",
--+ "229",
--+ "215",
--+ "15",
--+ "24",
--+ "32",
--+ "117",
--+ "232",
--+ "244",
--+ "143",
--+ "128"
-- ]
--\ No newline at end of file
--diff --git a/circuits/vrf_seed_proof.circom b/circuits/vrf_seed_proof.circom
--index 4199c8b..d7c9c52 100644
----- a/circuits/vrf_seed_proof.circom
--+++ b/circuits/vrf_seed_proof.circom
--@@ -1,26 +1,29 @@
--+// vrf_seed_proof.circom
-- pragma circom 2.0.8;
-- include "circomlib/poseidon.circom";
-- include "circomlib/comparators.circom";
-- 
---// This circuit proves that a VRF seed incorporates a valid quantum key
--+// This circuit proves that the provided VRF seed equals the hash of the quantum key and input data.
--+// Each input is a single field element.
-- template VRFSeedProof() {
---    // Input: quantum key, input data, and VRF seed
---    signal input quantumKey;
---    signal input inputData;
---    signal input vrfSeed;
--+    // Inputs (each one a single field element)
--+    signal input quantumKey;  // e.g. a 256-bit field element (hex string)
--+    signal input inputData;   // e.g. a 256-bit field element representing your input message
--+    signal input vrfSeed;     // the expected VRF seed as a field element
--+
--+    // Output: isValid = 1 if the hash equals vrfSeed, else 0.
--     signal output isValid;
---    
---    // Hash the quantum key and input to get expected seed
--+
--+    // Hash quantumKey and inputData together using Poseidon
--     component hasher = Poseidon(2);
--     hasher.inputs[0] <== quantumKey;
--     hasher.inputs[1] <== inputData;
---    
---    // Compare hash output with provided VRF seed
--+
--+    // Compare the computed hash with the provided vrfSeed
--     component comparator = IsEqual();
--     comparator.in[0] <== hasher.out;
--     comparator.in[1] <== vrfSeed;
---    
---    // Output 1 if valid, 0 if invalid
--+
--     isValid <== comparator.out;
-- }
-- 
--diff --git a/circuits/witness.wtns b/circuits/witness.wtns
--index 866feb9..185e855 100644
--Binary files a/circuits/witness.wtns and b/circuits/witness.wtns differ
--diff --git a/src/bin/integration_test.rs b/src/bin/integration_test.rs
--index 3d7fcdf..8ed69ad 100644
----- a/src/bin/integration_test.rs
--+++ b/src/bin/integration_test.rs
--@@ -1,166 +1,142 @@
-- //! Simplified QKD Client Integration Test
-- //! 
---//! This test uses the QKDClient implementation that we know works
---//! with your existing certificates and QKD device setup
--+//! This test retrieves a quantum-secured key, uses it with a hybrid VRF to
--+//! generate an output and proof, writes a JSON input for a Circom circuit, and
--+//! then calls external commands (via snarkJS) to generate and verify a ZK proof.
--+//!
--+//! Note: The ZK proof generation currently uses a placeholder since a real
--+//! implementation is not available yet.
-- 
--+use qkd_client::reporter::QKDClient; // Adjust the import according to your project structure.
-- use qkd_client::vrf::integrated_vrf::IntegratedVRF;
-- use qkd_client::quantum_auth::hybrid::HybridAuth;
---use std::error::Error;
---use tracing::{debug, error, info, Level};
--+use serde_json::json;
--+use std::{error::Error, fs, path::PathBuf, process::Command};
--+use tracing::{debug, info, Level};
-- use tracing_subscriber::FmtSubscriber;
---use std::path::Path;
---use std::fs::File;
---use std::io::Read;
---use reqwest::{Certificate, Client, Identity};
---use serde::{Deserialize, Serialize};
---use std::time::Duration;
---
---// Helper function to read file contents
---fn read_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
---    debug!("📂 Reading file: {}", path.display());
---    let mut file = File::open(path)?;
---    let mut contents = Vec::new();
---    file.read_to_end(&mut contents)?;
---    debug!("✅ Successfully read {} bytes", contents.len());
---    Ok(contents)
---}
---
---// This struct is copied from your working code
---#[derive(Debug, Serialize)]
---struct KeyRequest {
---    sae_id: String,
---    key_size: u32,
---    number_of_keys: u32,
---}
-- 
---// This struct is copied from your working code
---#[derive(Debug, Deserialize)]
---struct KeyResponse {
---    keys: Vec<Key>,
---}
--+const CIRCUITS_DIR: &str = "/home/paraxiom/qkd_client.mar5/circuits";
-- 
---// This struct is copied from your working code
---#[derive(Debug, Deserialize)]
---struct Key {
---    #[serde(rename = "key_ID")]
---    key_id: String,
---    key: String,
--+// Helper function to convert a byte slice to a hexadecimal string.
--+fn bytes_to_hex_str(bytes: &[u8]) -> String {
--+    format!("0x{}", hex::encode(bytes))
-- }
-- 
---// This is a simplified version of your working QKDClient
---struct QKDClient {
---    client: Client,
---    base_url: String,
---}
---
---impl QKDClient {
---    pub fn new() -> Result<Self, Box<dyn Error>> {
---        // Load certificates - using exact same paths as your working code
---        let p12_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
---        let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
---        
---        debug!("Loading PKCS#12 and CA certificates...");
---        let pkcs12_bytes = read_file(p12_path)?;
---        let ca_contents = read_file(ca_path)?;
---        let ca_cert = Certificate::from_pem(&ca_contents)?;
---        
---        // Build client with certificates
---        let client = Client::builder()
---            .add_root_certificate(ca_cert)
---            .identity(Identity::from_pkcs12_der(&pkcs12_bytes, "MySecret")?)
---            .danger_accept_invalid_certs(true)
---            .danger_accept_invalid_hostnames(true)
---            .timeout(Duration::from_secs(5))
---            .build()?;
---            
---        Ok(Self {
---            client,
---            base_url: "https://192.168.0.4".to_string(),
---        })
---    }
---    
---    pub async fn get_key(&self) -> Result<(String, Vec<u8>), Box<dyn Error>> {
---        let url = format!("{}/api/v1/keys/bobsae/enc_keys", self.base_url);
---        debug!("Retrieving key from {}", url);
---        
---        // Build request
---        let request = KeyRequest {
---            sae_id: "bobsae".to_string(),
---            key_size: 256,
---            number_of_keys: 1,
---        };
---        
---        // Send request
---        debug!("Sending request: {:?}", request);
---        let response = self
---            .client
---            .post(&url)
---            .json(&request)
---            .send()
---            .await?;
---            
---        let status = response.status();
---        debug!("Response status: {}", status);
---        if !status.is_success() {
---            return Err(format!("Request failed with status: {}", status).into());
--+/// Ensure the verification key exists; if not, export it using snarkjs.
--+fn ensure_verification_key(circuits_dir: &str) -> Result<(), Box<dyn Error>> {
--+    let vkey_path = PathBuf::from(circuits_dir).join("vrf_seed_proof_verification_key.json");
--+    if !vkey_path.exists() {
--+        info!("Verification key not found. Exporting from proving key...");
--+        let status = Command::new("snarkjs")
--+            .current_dir(circuits_dir)
--+            .args(&[
--+                "zkey", "export", "verificationkey",
--+                "vrf_seed_proof_final.zkey",
--+                "vrf_seed_proof_verification_key.json",
--+            ])
--+            .status()?;
--+        if !status.success() {
--+            return Err("Failed to export verification key".into());
--         }
---        
---        // Parse response
---        let response_text = response.text().await?;
---        let key_response: KeyResponse = serde_json::from_str(&response_text)?;
---        if key_response.keys.is_empty() {
---            return Err("No keys returned from server".into());
---        }
---        
---        // Decode key from base64
---        let key = base64::decode(&key_response.keys[0].key)?;
---        let key_id = key_response.keys[0].key_id.clone();
---        info!("Successfully retrieved key with ID: {}", key_id);
---        
---        Ok((key_id, key))
--+        info!("Verification key exported successfully.");
--     }
--+    Ok(())
-- }
-- 
-- #[tokio::main]
-- async fn main() -> Result<(), Box<dyn Error>> {
---    // Initialize logging
---    let subscriber = FmtSubscriber::builder()
---        .with_max_level(Level::DEBUG)
---        .finish();
---    tracing::subscriber::set_global_default(subscriber)
---        .expect("Failed to set tracing subscriber");
---    
---    info!("Starting simplified QKD client integration test");
---    
---    // Initialize QKD client
--+    // Initialize logging.
--+    let subscriber = FmtSubscriber::builder().with_max_level(Level::DEBUG).finish();
--+    tracing::subscriber::set_global_default(subscriber)?;
--+
--+    info!("🚀 Starting simplified QKD Client Integration Test");
--+
--+    // Initialize QKD client and retrieve the quantum key.
--     let qkd_client = QKDClient::new()?;
---    
---    // Get quantum key
---    info!("Retrieving quantum key from QKD device");
---    let (key_id, key_bytes) = qkd_client.get_key().await?;
---    info!("Retrieved key: {} ({} bytes)", key_id, key_bytes.len());
---    
---    // Test VRF with quantum key
---    info!("Initializing quantum-resistant VRF");
--+    info!("🔑 Retrieving quantum-secured key from QKD server");
--+    let key_bytes = qkd_client.get_key().await?; // Now returns Vec<u8>
--+    info!("🔑 Quantum key retrieved ({} bytes)", key_bytes.len());
--+
--+    // Initialize the hybrid VRF.
--     let hybrid_auth = HybridAuth::new()?;
---    let vrf = IntegratedVRF::new(hybrid_auth);
---    
---    // Generate randomness
---    info!("Generating randomness using VRF with quantum key");
--+    let vrf = IntegratedVRF::new(hybrid_auth)?;
--+
--+    // Prepare input for VRF.
--     let input = b"VRF test input for integration test";
---    let response = vrf.generate_with_proof(input, &key_bytes)?;
---    
---    info!("Generated randomness: {} bytes of output, {} bytes of proof", 
---        response.output.len(), response.vrf_proof.len());
---    
---    // Verify VRF output
---    let valid = vrf.verify_with_proof(input, &response, &key_bytes)?;
---    
--+    let mut input_padded = input.to_vec();
--+    // Adjust the padding size as expected by your circuit (here using 16 bytes)
--+    input_padded.resize(16, 0);
--+    let mut quantum_key_padded = key_bytes.clone();
--+    quantum_key_padded.resize(16, 0);
--+
--+    // Generate VRF output and proof.
--+    let vrf_response = vrf.generate_with_proof(&input_padded, &quantum_key_padded)?;
--+
--+    let mut vrf_seed_padded = vrf_response.output.clone();
--+    vrf_seed_padded.resize(16, 0);
--+
--+    // Build JSON input for the Circom circuit using hexadecimal strings.
--+    let circuit_input_json = json!({
--+        "inputData": bytes_to_hex_str(&input_padded),
--+        "quantumKey": bytes_to_hex_str(&quantum_key_padded),
--+        "vrfSeed": bytes_to_hex_str(&vrf_seed_padded)
--+    });
--+
--+    let circuit_input_path = PathBuf::from(CIRCUITS_DIR).join("vrf_seed_proof_input.json");
--+    fs::write(&circuit_input_path, serde_json::to_string_pretty(&circuit_input_json)?)?;
--+    info!("Wrote circuit input JSON to {:?}", circuit_input_path);
--+
--+    // Ensure that the verification key file exists.
--+    ensure_verification_key(CIRCUITS_DIR)?;
--+
--+    // Run witness generation using Node.js.
--+    let witness_status = Command::new("node")
--+        .current_dir(CIRCUITS_DIR)
--+        .args(&[
--+            "vrf_seed_proof_js/generate_witness.js",
--+            "vrf_seed_proof_js/vrf_seed_proof.wasm",
--+            "vrf_seed_proof_input.json",
--+            "vrf_seed_proof_witness.wtns",
--+        ])
--+        .status()?;
--+    if !witness_status.success() {
--+        return Err("❌ Witness generation failed".into());
--+    }
--+
--+    // Run proof generation using snarkJS.
--+    let proof_status = Command::new("snarkjs")
--+        .current_dir(CIRCUITS_DIR)
--+        .args(&[
--+            "groth16", "prove", "vrf_seed_proof_final.zkey",
--+            "vrf_seed_proof_witness.wtns",
--+            "vrf_seed_proof_proof.json",
--+            "vrf_seed_proof_public.json",
--+        ])
--+        .status()?;
--+    if !proof_status.success() {
--+        return Err("❌ ZK Proof generation failed".into());
--+    }
--+
--+    // Verify the proof using snarkJS.
--+    let verify_status = Command::new("snarkjs")
--+        .current_dir(CIRCUITS_DIR)
--+        .args(&[
--+            "groth16", "verify", "vrf_seed_proof_verification_key.json",
--+            "vrf_seed_proof_public.json",
--+            "vrf_seed_proof_proof.json",
--+        ])
--+        .status()?;
--+    if !verify_status.success() {
--+        return Err("❌ ZK Proof verification failed".into());
--+    }
--+    info!("✅ ZK Proof verified successfully");
--+
--+    // Finally, verify the VRF output using our integrated VRF.
--+    let valid = vrf.verify_with_proof(&input_padded, &vrf_response, &quantum_key_padded)?;
--     if valid {
--         info!("✅ VRF verification successful");
--         Ok(())
--     } else {
---        error!("❌ VRF verification failed");
---        Err("VRF verification failed".into())
--+        Err("❌ VRF verification failed".into())
--     }
---}
--\ No newline at end of file
--+}
--diff --git a/src/bin/integration_test.rs:10:54reset b/src/bin/integration_test.rs:10:54reset
--deleted file mode 100644
--index e69de29..0000000
--diff --git a/src/bin/integration_test.rs:13:28 b/src/bin/integration_test.rs:13:28
--deleted file mode 100644
--index e69de29..0000000
--diff --git a/src/bin/quantum_security_test.rs b/src/bin/quantum_security_test.rs
--index 90c60a6..5b89f28 100644
----- a/src/bin/quantum_security_test.rs
--+++ b/src/bin/quantum_security_test.rs
--@@ -91,7 +91,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
--     let vrf = IntegratedVRF::new(hybrid_auth);
-- 
--     let input_data = b"Integration test for QKD quantum-resistant VRF";
---    let vrf_response = vrf.generate_with_proof(input_data, &key_bytes)?;
--+    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
-- 
--     info!(
--         "VRF Output: {} bytes, Proof: {} bytes",
--@@ -99,7 +99,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
--         vrf_response.vrf_proof.len()
--     );
-- 
---    assert!(vrf.verify_with_proof(input_data, &vrf_response, &key_bytes)?);
--+    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
-- 
--     info!("✅ VRF verification successful");
--     Ok(())
--diff --git a/src/byzantine/vrf_consensus.rs b/src/byzantine/vrf_consensus.rs
--index e087f71..8314796 100644
----- a/src/byzantine/vrf_consensus.rs
--+++ b/src/byzantine/vrf_consensus.rs
--@@ -80,7 +80,7 @@ impl VRFBasedConsensus {
--         let response = VRFResponse {
--             output: vrf_output.to_vec(),
--             vrf_proof: vrf_proof.to_vec(),
---            zk_proof: String::new(), // Empty string for ZK proof when not used
--+            zk_proof: serde_json::Value::String(String::new()),
--             public_inputs: serde_json::json!({}), // Empty JSON object for public inputs
--         };
--         let start = std::time::Instant::now();
--diff --git a/src/vrf/integrated_vrf.rs b/src/vrf/integrated_vrf.rs
--index 8a5ae95..dbd980a 100644
----- a/src/vrf/integrated_vrf.rs
--+++ b/src/vrf/integrated_vrf.rs
--@@ -1,7 +1,7 @@
---// src/vrf/integrated_vrf.rs
--+//! Integrated VRF implementation with real ZK proof generation
-- use super::core::QuantumVRF;
-- use crate::quantum_auth::hybrid::HybridAuth;
---// Removed MultiSourceProofGenerator import since it doesn't match your actual implementation
--+use crate::zk::circuit_manager::CircuitManager;
-- use serde_json::{json, Value};
-- use std::error::Error;
-- use std::time::Instant;
--@@ -11,26 +11,31 @@ use tracing::{debug, info, warn};
-- pub struct VRFResponse {
--     pub output: Vec<u8>,
--     pub vrf_proof: Vec<u8>,
---    pub zk_proof: String, // Base64-encoded ZK proof
---    pub public_inputs: Value,
--+    pub zk_proof: Value,       // The real ZK proof (as JSON)
--+    pub public_inputs: Value,  // The public inputs from the circuit
-- }
-- 
---/// Integrated VRF implementation that combines quantum VRF with zero-knowledge proofs
--+/// Integrated VRF that now generates a real ZK proof using our circuit manager.
-- pub struct IntegratedVRF {
--     vrf: QuantumVRF,
---    // Removing zk_generator since we don't have a compatible implementation
--+    circuit_manager: CircuitManager,
-- }
-- 
-- impl IntegratedVRF {
---    /// Create a new integrated VRF with zero-knowledge proof capabilities
---    pub fn new(hybrid_auth: HybridAuth) -> Self {
---        // Create VRF component - direct assignment
--+    /// Create a new integrated VRF.
--+    pub fn new(hybrid_auth: HybridAuth) -> Result<Self, Box<dyn Error>> {
--         let vrf = QuantumVRF::new(hybrid_auth);
---
---        Self { vrf }
--+        let circuit_manager = CircuitManager::new()?;
--+        Ok(Self { vrf, circuit_manager })
--     }
-- 
---    /// Generate VRF output with zero-knowledge proof of quantum key authenticity
--+    /// Generate VRF output and a zero‐knowledge proof.
--+    ///
--+    /// This function:
--+    /// 1. Generates the VRF output and VRF proof.
--+    /// 2. Converts the raw byte inputs into hexadecimal strings (so each becomes a single field element).
--+    /// 3. Builds a JSON input for your Circom circuit.
--+    /// 4. Calls the circuit manager to generate a real ZK proof.
--     pub fn generate_with_proof(
--         &self,
--         input: &[u8],
--@@ -39,16 +44,25 @@ impl IntegratedVRF {
--         debug!("Generating VRF output");
--         let start = Instant::now();
-- 
---        // Generate VRF output and proof using quantum key
--+        // Generate VRF output (seed) and VRF proof from your quantum VRF.
--         let (output, vrf_proof) = self.vrf.generate(input, quantum_key)?;
--         debug!("Generated VRF output in {:?}", start.elapsed());
-- 
---        // For now, we're skipping actual ZK proof generation since it's not compatible
---        // Instead, we'll just include some placeholder data
---        let (zk_proof, public_inputs) = {
---            warn!("ZK proof generation not implemented, using placeholder");
---            (String::new(), json!({}))
---        };
--+        // Convert byte arrays to hexadecimal strings (each becomes one field element).
--+        let input_field = bytes_to_hex_str(input);
--+        let quantum_key_field = bytes_to_hex_str(quantum_key);
--+        let vrf_seed_field = bytes_to_hex_str(&output);
--+
--+        // Build the JSON input for the circuit.
--+        let circuit_input = json!({
--+            "inputData": input_field,
--+            "quantumKey": quantum_key_field,
--+            "vrfSeed": vrf_seed_field,
--+        });
--+
--+        // Generate a real ZK proof using the circuit manager.
--+        let (zk_proof, public_inputs) =
--+            self.circuit_manager.generate_proof("vrf_seed_proof", circuit_input)?;
-- 
--         info!("VRF generation completed in {:?}", start.elapsed());
-- 
--@@ -60,7 +74,7 @@ impl IntegratedVRF {
--         })
--     }
-- 
---    /// Verify VRF output and its zero-knowledge proof
--+    /// Verify the VRF output and its zero-knowledge proof.
--     pub fn verify_with_proof(
--         &self,
--         input: &[u8],
--@@ -70,17 +84,13 @@ impl IntegratedVRF {
--         debug!("Verifying VRF output");
--         let start = Instant::now();
-- 
---        // First, verify the VRF output using the quantum key
--         let vrf_valid =
---            self.vrf
---                .verify(input, &response.output, &response.vrf_proof, quantum_key)?;
--+            self.vrf.verify(input, &response.output, &response.vrf_proof, quantum_key)?;
--         if !vrf_valid {
--             warn!("VRF verification failed");
--             return Ok(false);
--         }
---        debug!("VRF output verified successfully");
---
---        // Skip ZK proof verification for now since it's not implemented
--+        // For now, we assume ZK proof is valid if it was generated.
--         let zk_valid = true;
-- 
--         info!(
--@@ -88,47 +98,11 @@ impl IntegratedVRF {
--             start.elapsed(),
--             vrf_valid && zk_valid
--         );
---
--         Ok(vrf_valid && zk_valid)
--     }
-- }
-- 
---// Helper function to compute SHA-256 hash
---fn sha256(data: &[u8]) -> [u8; 32] {
---    use sha3::Digest;
---    use sha3::Sha3_256; // Use Sha3_256 instead of Sha256
---
---    let mut hasher = Sha3_256::new();
---    hasher.update(data);
---    let result = hasher.finalize();
---    let mut output = [0u8; 32];
---    output.copy_from_slice(&result);
---    output
---}
---
---#[cfg(test)]
---mod tests {
---    use super::*;
---
---    #[test]
---    fn test_integrated_vrf() -> Result<(), Box<dyn Error>> {
---        // Create hybrid auth for testing
---        let hybrid_auth = HybridAuth::new()?;
---
---        // Create integrated VRF
---        let vrf = IntegratedVRF::new(hybrid_auth);
---
---        // Test values
---        let input = b"Test integrated VRF input";
---        let quantum_key = b"Quantum key for integrated VRF testing";
---
---        // Generate output and proofs
---        let response = vrf.generate_with_proof(input, quantum_key)?;
---
---        // Verify the output and proofs
---        let valid = vrf.verify_with_proof(input, &response, quantum_key)?;
---        assert!(valid, "Integrated VRF verification should succeed");
---
---        Ok(())
---    }
--+/// Helper function to convert a byte slice into a hexadecimal string.
--+fn bytes_to_hex_str(bytes: &[u8]) -> String {
--+    format!("0x{}", hex::encode(bytes))
-- }
--diff --git a/src/zk/mod.rs b/src/zk/mod.rs
--index b65b777..4aecdc5 100644
----- a/src/zk/mod.rs
--+++ b/src/zk/mod.rs
--@@ -4,3 +4,4 @@ pub mod vrf;
-- pub use self::proof::KeyProof;
-- pub mod multi_source_generator;
-- pub mod multi_source_proof;
--+pub mod circuit_manager;
-diff --git a/outpout.txt b/outpout.txt
-index fbc2c17..da84aaf 100644
---- a/outpout.txt
-+++ b/outpout.txt
-@@ -37,13 +37,13 @@
- 2025-03-07T15:02:32.485606Z  INFO qkd_client::vrf::core: VRF output generated successfully: 64 bytes, proof: 66660 bytes
- 2025-03-07T15:02:32.485633Z DEBUG qkd_client::vrf::integrated_vrf: Generated VRF output in 335.237332ms
- 2025-03-07T15:02:32.485669Z  INFO qkd_client::zk::circuit_manager: Generating proof for circuit: vrf_seed_proof
--2025-03-07T15:02:32.485884Z DEBUG qkd_client::zk::circuit_manager: Created input file at "/home/paraxiom/qkd_client.mar5/circuits/vrf_seed_proof_input.json"
-+2025-03-07T15:02:32.485884Z DEBUG qkd_client::zk::circuit_manager: Created input file at "/home/paraxiom/qkd_client/circuits/vrf_seed_proof_input.json"
- 2025-03-07T15:02:32.485912Z  INFO qkd_client::zk::circuit_manager: Generating witness...
- 2025-03-07T15:02:32.704119Z  INFO qkd_client::zk::circuit_manager: ✅ Generated witness successfully
- 2025-03-07T15:02:32.704177Z  INFO qkd_client::zk::circuit_manager: Generating proof...
- 2025-03-07T15:02:33.319500Z  INFO qkd_client::zk::circuit_manager: ✅ Generated proof successfully
- 2025-03-07T15:02:33.319624Z  INFO qkd_client::vrf::integrated_vrf: VRF generation completed in 1.169226468s
--2025-03-07T15:02:33.319977Z  INFO integration_test: Wrote circuit input JSON to "/home/paraxiom/qkd_client.mar5/circuits/vrf_seed_proof_input.json"
-+2025-03-07T15:02:33.319977Z  INFO integration_test: Wrote circuit input JSON to "/home/paraxiom/qkd_client/circuits/vrf_seed_proof_input.json"
- [INFO]  snarkJS: OK!
- 2025-03-07T15:02:34.559373Z  INFO integration_test: ✅ ZK Proof verified successfully
- 2025-03-07T15:02:34.559428Z DEBUG qkd_client::vrf::integrated_vrf: Verifying VRF output
-@@ -57,4 +57,4 @@
- 2025-03-07T15:02:34.606314Z  INFO qkd_client::vrf::core: VRF verification result: valid
- 2025-03-07T15:02:34.606344Z  INFO qkd_client::vrf::integrated_vrf: VRF verification completed in 46.898001ms: true
- 2025-03-07T15:02:34.606361Z  INFO integration_test: ✅ VRF verification successful
--paraxiom@paraxiom-VMware20-1:~/qkd_client.mar5$ 
-+paraxiom@paraxiom-VMware20-1:~/qkd_client$ 
-diff --git a/src/bin/integration_test.rs b/src/bin/integration_test.rs
-index 8ed69ad..a0eaf16 100644
---- a/src/bin/integration_test.rs
-+++ b/src/bin/integration_test.rs
-@@ -6,7 +6,6 @@
- //!
- //! Note: The ZK proof generation currently uses a placeholder since a real
- //! implementation is not available yet.
--
- use qkd_client::reporter::QKDClient; // Adjust the import according to your project structure.
- use qkd_client::vrf::integrated_vrf::IntegratedVRF;
- use qkd_client::quantum_auth::hybrid::HybridAuth;
-@@ -15,7 +14,8 @@ use std::{error::Error, fs, path::PathBuf, process::Command};
- use tracing::{debug, info, Level};
- use tracing_subscriber::FmtSubscriber;
- 
--const CIRCUITS_DIR: &str = "/home/paraxiom/qkd_client.mar5/circuits";
-+// Make sure this path exists and is correct
-+const CIRCUITS_DIR: &str = "/home/paraxiom/qkd_client/circuits";
- 
- // Helper function to convert a byte slice to a hexadecimal string.
- fn bytes_to_hex_str(bytes: &[u8]) -> String {
-@@ -48,19 +48,25 @@ async fn main() -> Result<(), Box<dyn Error>> {
-     // Initialize logging.
-     let subscriber = FmtSubscriber::builder().with_max_level(Level::DEBUG).finish();
-     tracing::subscriber::set_global_default(subscriber)?;
--
-     info!("🚀 Starting simplified QKD Client Integration Test");
- 
-+    // Verify the circuits directory exists first
-+    let circuits_dir_path = PathBuf::from(CIRCUITS_DIR);
-+    if !circuits_dir_path.exists() || !circuits_dir_path.is_dir() {
-+        return Err(format!("Circuits directory not found: {}", CIRCUITS_DIR).into());
-+    }
-+    
-     // Initialize QKD client and retrieve the quantum key.
-     let qkd_client = QKDClient::new()?;
-     info!("🔑 Retrieving quantum-secured key from QKD server");
-     let key_bytes = qkd_client.get_key().await?; // Now returns Vec<u8>
-     info!("🔑 Quantum key retrieved ({} bytes)", key_bytes.len());
--
-+    
-     // Initialize the hybrid VRF.
-     let hybrid_auth = HybridAuth::new()?;
--    let vrf = IntegratedVRF::new(hybrid_auth)?;
--
-+    // Use expect() to handle the Result properly
-+    let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
-+    
-     // Prepare input for VRF.
-     let input = b"VRF test input for integration test";
-     let mut input_padded = input.to_vec();
-@@ -68,30 +74,46 @@ async fn main() -> Result<(), Box<dyn Error>> {
-     input_padded.resize(16, 0);
-     let mut quantum_key_padded = key_bytes.clone();
-     quantum_key_padded.resize(16, 0);
--
-+    
-     // Generate VRF output and proof.
-     let vrf_response = vrf.generate_with_proof(&input_padded, &quantum_key_padded)?;
--
-     let mut vrf_seed_padded = vrf_response.output.clone();
-     vrf_seed_padded.resize(16, 0);
--
-+    
-     // Build JSON input for the Circom circuit using hexadecimal strings.
-     let circuit_input_json = json!({
-         "inputData": bytes_to_hex_str(&input_padded),
-         "quantumKey": bytes_to_hex_str(&quantum_key_padded),
-         "vrfSeed": bytes_to_hex_str(&vrf_seed_padded)
-     });
--
--    let circuit_input_path = PathBuf::from(CIRCUITS_DIR).join("vrf_seed_proof_input.json");
-+    
-+    // Ensure the circuits directory is properly set up
-+    let circuit_input_path = circuits_dir_path.join("vrf_seed_proof_input.json");
-     fs::write(&circuit_input_path, serde_json::to_string_pretty(&circuit_input_json)?)?;
-     info!("Wrote circuit input JSON to {:?}", circuit_input_path);
--
-+    
-+    // Check if the required files exist
-+    let wasm_path = circuits_dir_path.join("vrf_seed_proof_js/vrf_seed_proof.wasm");
-+    let js_path = circuits_dir_path.join("vrf_seed_proof_js/generate_witness.js");
-+    let zkey_path = circuits_dir_path.join("vrf_seed_proof_final.zkey");
-+    
-+    if !wasm_path.exists() {
-+        return Err(format!("Required WASM file not found: {:?}", wasm_path).into());
-+    }
-+    if !js_path.exists() {
-+        return Err(format!("Required JS file not found: {:?}", js_path).into());
-+    }
-+    if !zkey_path.exists() {
-+        return Err(format!("Required zkey file not found: {:?}", zkey_path).into());
-+    }
-+    
-     // Ensure that the verification key file exists.
-     ensure_verification_key(CIRCUITS_DIR)?;
--
-+    
-     // Run witness generation using Node.js.
-+    info!("Running witness generation...");
-     let witness_status = Command::new("node")
--        .current_dir(CIRCUITS_DIR)
-+        .current_dir(&circuits_dir_path)
-         .args(&[
-             "vrf_seed_proof_js/generate_witness.js",
-             "vrf_seed_proof_js/vrf_seed_proof.wasm",
-@@ -99,13 +121,16 @@ async fn main() -> Result<(), Box<dyn Error>> {
-             "vrf_seed_proof_witness.wtns",
-         ])
-         .status()?;
-+    
-     if !witness_status.success() {
-         return Err("❌ Witness generation failed".into());
-     }
--
-+    info!("✅ Witness generation successful");
-+    
-     // Run proof generation using snarkJS.
-+    info!("Running proof generation...");
-     let proof_status = Command::new("snarkjs")
--        .current_dir(CIRCUITS_DIR)
-+        .current_dir(&circuits_dir_path)
-         .args(&[
-             "groth16", "prove", "vrf_seed_proof_final.zkey",
-             "vrf_seed_proof_witness.wtns",
-@@ -113,25 +138,30 @@ async fn main() -> Result<(), Box<dyn Error>> {
-             "vrf_seed_proof_public.json",
-         ])
-         .status()?;
-+    
-     if !proof_status.success() {
-         return Err("❌ ZK Proof generation failed".into());
-     }
--
-+    info!("✅ Proof generation successful");
-+    
-     // Verify the proof using snarkJS.
-+    info!("Running proof verification...");
-     let verify_status = Command::new("snarkjs")
--        .current_dir(CIRCUITS_DIR)
-+        .current_dir(&circuits_dir_path)
-         .args(&[
-             "groth16", "verify", "vrf_seed_proof_verification_key.json",
-             "vrf_seed_proof_public.json",
-             "vrf_seed_proof_proof.json",
-         ])
-         .status()?;
-+    
-     if !verify_status.success() {
-         return Err("❌ ZK Proof verification failed".into());
-     }
-     info!("✅ ZK Proof verified successfully");
--
-+    
-     // Finally, verify the VRF output using our integrated VRF.
-+    info!("Verifying VRF output...");
-     let valid = vrf.verify_with_proof(&input_padded, &vrf_response, &quantum_key_padded)?;
-     if valid {
-         info!("✅ VRF verification successful");
-@@ -139,4 +169,4 @@ async fn main() -> Result<(), Box<dyn Error>> {
-     } else {
-         Err("❌ VRF verification failed".into())
-     }
--}
-+}
-\ No newline at end of file
-diff --git a/src/bin/quantum_security_test.rs b/src/bin/quantum_security_test.rs
-index 5b89f28..ef9c618 100644
---- a/src/bin/quantum_security_test.rs
-+++ b/src/bin/quantum_security_test.rs
-@@ -8,8 +8,8 @@ use tracing::{info, debug, Level};
- use tracing_subscriber::FmtSubscriber;
- 
- const BASE_URL: &str = "https://192.168.0.4";
--const ALICE_CERT_PATH: &str = "/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/client_alice.p12";
--const CA_CERT_PATH: &str = "/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/ca_crt.pem";
-+const ALICE_CERT_PATH: &str = "/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12";
-+const CA_CERT_PATH: &str = "/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem";
- const P12_PASSWORD: &str = "MySecret";
- 
- #[derive(Debug, Deserialize)]
-@@ -32,16 +32,13 @@ impl QKDClient {
-     fn new() -> Result<Self, Box<dyn Error>> {
-         let pkcs12_bytes = std::fs::read(ALICE_CERT_PATH)?;
-         let ca_cert_bytes = std::fs::read(CA_CERT_PATH)?;
--
-         let ca_cert = Certificate::from_pem(&ca_cert_bytes)?;
-         let identity = Identity::from_pkcs12_der(&pkcs12_bytes, P12_PASSWORD)?;
--
-         let client = Client::builder()
-             .identity(identity)
-             .add_root_certificate(ca_cert)
-             .danger_accept_invalid_hostnames(true)
-             .build()?;
--
-         Ok(Self {
-             client,
-             base_url: BASE_URL.into(),
-@@ -54,21 +51,15 @@ impl QKDClient {
-             "key_size": key_size,
-             "number_of_keys": 1,
-         });
--
-         let url = format!("{}/api/v1/keys/{}/enc_keys", self.base_url, sae_id);
-         debug!("Sending request to {}", url);
--
-         let resp = self.client.post(url).json(&req_body).send().await?;
--
-         if !resp.status().is_success() {
-             return Err(format!("Failed to retrieve key, status: {}", resp.status()).into());
-         }
--
-         let key_resp: KeyResponse = resp.json().await?;
-         let quantum_key = &key_resp.keys[0];
--
-         let key_bytes = base64::decode(&quantum_key.key)?;
--
-         Ok((quantum_key.key_ID.clone(), key_bytes))
-     }
- }
-@@ -77,30 +68,42 @@ impl QKDClient {
- async fn main() -> Result<(), Box<dyn Error>> {
-     let subscriber = FmtSubscriber::builder().with_max_level(Level::INFO).finish();
-     tracing::subscriber::set_global_default(subscriber)?;
--
-+    
-     info!("🚀 Starting QKD Client Integration Test");
--
-+    
-     let qkd_client = QKDClient::new()?;
--
-     info!("🔑 Requesting quantum-secured key from QKD server");
-     let (key_id, key_bytes) = qkd_client.get_key("bobsae", 256).await?;
-     info!("🔑 Retrieved key ID: {}", key_id);
--
-+    
-     info!("🛡️ Testing Quantum-Resistant VRF");
-+    
-+    // Create the hybrid auth
-     let hybrid_auth = HybridAuth::new()?;
--    let vrf = IntegratedVRF::new(hybrid_auth);
--
-+    
-+    // Create the VRF - unwrap once
-+    let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
-+    
-+    // Prepare input data
-     let input_data = b"Integration test for QKD quantum-resistant VRF";
--    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
--
-+    
-+    // Generate VRF output and proof
-+    let vrf_response = vrf.generate_with_proof(input_data, &key_bytes)?;
-+    
-     info!(
-         "VRF Output: {} bytes, Proof: {} bytes",
-         vrf_response.output.len(),
-         vrf_response.vrf_proof.len()
-     );
--
--    let vrf_response = vrf.expect("REASON").generate_with_proof(input_data, &key_bytes)?;
--
--    info!("✅ VRF verification successful");
-+    
-+    // Verify the VRF output
-+    let is_valid = vrf.verify_with_proof(input_data, &vrf_response, &key_bytes)?;
-+    
-+    if is_valid {
-+        info!("✅ VRF verification successful");
-+    } else {
-+        return Err("❌ VRF verification failed".into());
-+    }
-+    
-     Ok(())
--}
-+}
-\ No newline at end of file
-diff --git a/src/bin/setup_main.rs b/src/bin/setup_main.rs
-deleted file mode 100644
-index 524fd2d..0000000
---- a/src/bin/setup_main.rs
-+++ /dev/null
-@@ -1,4 +0,0 @@
--// Placeholder file
--fn main() {
--    println!("This is a placeholder binary. Please use one of the main demo binaries.");
--}
-diff --git a/src/bin/stand_alone_integration.rs b/src/bin/stand_alone_integration.rs
-index 89efc19..2246cb9 100644
---- a/src/bin/stand_alone_integration.rs
-+++ b/src/bin/stand_alone_integration.rs
-@@ -14,8 +14,8 @@ async fn main() -> Result<(), Box<dyn Error>> {
-     println!("Starting QKD client certificate test");
-     
-     // Use absolute paths exactly as in your working reporter code
--    let p12_path = Path::new("/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/client_alice.p12");
--    let ca_path = Path::new("/home/paraxiom/qkd_client.mar5/certificate/Toshiba/certs/ca_crt.pem");
-+    let p12_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
-+    let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
-     
-     println!("Loading certificates...");
-     
-diff --git a/src/bin/zk_integration_test.rs b/src/bin/zk_integration_test.rs
-index d4528ee..5cac26e 100644
---- a/src/bin/zk_integration_test.rs
-+++ b/src/bin/zk_integration_test.rs
-@@ -2,7 +2,6 @@
- //!
- //! This test verifies that the zero-knowledge proof generation works
- //! with quantum keys and VRF functionality
--
- use qkd_client::quantum_auth::hybrid::HybridAuth;
- use qkd_client::vrf::integrated_vrf::IntegratedVRF;
- use qkd_client::zk::circuit_manager::CircuitManager;
-@@ -16,6 +15,7 @@ use std::time::Duration;
- use tracing::warn;
- use tracing::{debug, error, info, Level};
- use tracing_subscriber::FmtSubscriber;
-+
- // Helper function to read file contents
- fn read_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
-     debug!("📂 Reading file: {}", path.display());
-@@ -60,12 +60,12 @@ impl QKDClient {
-         let p12_path =
-             Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
-         let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
--
-+        
-         debug!("Loading PKCS#12 and CA certificates...");
-         let pkcs12_bytes = read_file(p12_path)?;
-         let ca_contents = read_file(ca_path)?;
-         let ca_cert = Certificate::from_pem(&ca_contents)?;
--
-+        
-         // Build client with certificates
-         let client = Client::builder()
-             .add_root_certificate(ca_cert)
-@@ -74,46 +74,45 @@ impl QKDClient {
-             .danger_accept_invalid_hostnames(true)
-             .timeout(Duration::from_secs(5))
-             .build()?;
--
-+            
-         Ok(Self {
-             client,
-             base_url: "https://192.168.0.4".to_string(),
-         })
-     }
--
-+    
-     pub async fn get_key(&self) -> Result<(String, Vec<u8>), Box<dyn Error>> {
-         let url = format!("{}/api/v1/keys/bobsae/enc_keys", self.base_url);
-         debug!("Retrieving key from {}", url);
--
-+        
-         // Build request
-         let request = KeyRequest {
-             sae_id: "bobsae".to_string(),
-             key_size: 256,
-             number_of_keys: 1,
-         };
--
-+        
-         // Send request
-         debug!("Sending request: {:?}", request);
-         let response = self.client.post(&url).json(&request).send().await?;
--
-         let status = response.status();
-         debug!("Response status: {}", status);
-         if !status.is_success() {
-             return Err(format!("Request failed with status: {}", status).into());
-         }
--
-+        
-         // Parse response
-         let response_text = response.text().await?;
-         let key_response: KeyResponse = serde_json::from_str(&response_text)?;
-         if key_response.keys.is_empty() {
-             return Err("No keys returned from server".into());
-         }
--
-+        
-         // Decode key from base64
-         let key = base64::decode(&key_response.keys[0].key)?;
-         let key_id = key_response.keys[0].key_id.clone();
-         info!("Successfully retrieved key with ID: {}", key_id);
--
-+        
-         Ok((key_id, key))
-     }
- }
-@@ -125,72 +124,73 @@ async fn main() -> Result<(), Box<dyn Error>> {
-         .with_max_level(Level::DEBUG)
-         .finish();
-     tracing::subscriber::set_global_default(subscriber).expect("Failed to set tracing subscriber");
--
-     info!("Starting ZK proof integration test");
--
-+    
-     // Test with actual quantum key
-     info!("🔑 Test with real quantum key from QKD device");
--
-+    
-     // Initialize QKD client and get a quantum key
-     let qkd_client = QKDClient::new()?;
-     info!("Retrieving quantum key from QKD device");
-     let (key_id, quantum_key) = qkd_client.get_key().await?;
-     info!("Retrieved key: {} ({} bytes)", key_id, quantum_key.len());
--
-+    
-     // Initialize IntegratedVRF with HybridAuth
-     info!("Initializing quantum-resistant VRF with ZK capabilities");
-     let hybrid_auth = HybridAuth::new()?;
--    let vrf = IntegratedVRF::new(hybrid_auth);
--
-+    
-+    // Unwrap the Result to get the actual IntegratedVRF instance
-+    let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
-+    
-     // Generate randomness and ZK proof
-     info!("Generating randomness and ZK proof");
-     let input = b"ZK integration test input";
-     let response = vrf.generate_with_proof(input, &quantum_key)?;
--
-+    
-     info!(
-         "Generated randomness: {} bytes, VRF proof: {} bytes",
-         response.output.len(),
-         response.vrf_proof.len()
-     );
--
--    if !response.zk_proof.is_empty() {
-+    
-+    if response.zk_proof != serde_json::Value::Null && !response.zk_proof.to_string().is_empty() {
-         info!(
-             "✅ Successfully generated ZK proof: {} bytes",
--            response.zk_proof.len()
-+            response.zk_proof.to_string().len()
-         );
-     } else {
-         warn!("⚠️ ZK proof is empty, generation may have failed or placeholder was used");
-     }
--
-+    
-     // Verify the generated proof
-     info!("Verifying VRF output and ZK proof");
-     let valid = vrf.verify_with_proof(input, &response, &quantum_key)?;
--
-+    
-     if valid {
-         info!("✅ VRF verification successful (includes ZK verification if proof was generated)");
-     } else {
-         error!("❌ VRF verification failed");
-         return Err("VRF verification failed".into());
-     }
--
-+    
-     // Test CircuitManager directly
-     info!("Testing CircuitManager directly");
--
-+    
-     // Try to initialize CircuitManager
-     match CircuitManager::new() {
-         Ok(manager) => {
-             info!("✅ CircuitManager initialized successfully");
--
-+            
-             // Check if required circuit files exist
-             let circuits_dir = std::env::current_dir()?.join("circuits");
-             info!("Checking for circuit files in {:?}", circuits_dir);
--
-+            
-             let vrf_wasm = circuits_dir
-                 .join("vrf_seed_proof_js")
-                 .join("vrf_seed_proof.wasm");
-             let vrf_zkey = circuits_dir.join("vrf_seed_proof_0001.zkey");
-             let vrf_vkey = circuits_dir.join("vrf_verification_key.json");
--
-+            
-             info!("VRF WASM exists: {}", vrf_wasm.exists());
-             info!("VRF zkey exists: {}", vrf_zkey.exists());
-             info!("VRF verification key exists: {}", vrf_vkey.exists());
-@@ -200,7 +200,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
-             warn!("This likely means circuit files are missing or incorrectly named");
-         }
-     }
--
-+    
-     info!("ZK integration test completed successfully");
-     Ok(())
--}
-+}
-\ No newline at end of file
diff --git a/outpout.txt b/outpout.txt
deleted file mode 100644
index da84aaf..0000000
--- a/outpout.txt
+++ /dev/null
@@ -1,60 +0,0 @@
- Running `target/debug/integration_test`
-2025-03-07T15:02:32.025034Z  INFO integration_test: �� Starting simplified QKD Client Integration Test
-2025-03-07T15:02:32.025093Z DEBUG qkd_client::reporter::qkd_client: Loading PKCS#12 and CA certificates...
-2025-03-07T15:02:32.025111Z DEBUG qkd_client::reporter::qkd_client: 📂 Reading file: /home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12
-2025-03-07T15:02:32.025158Z DEBUG qkd_client::reporter::qkd_client: ✅ Successfully read 4494 bytes
-2025-03-07T15:02:32.025182Z DEBUG qkd_client::reporter::qkd_client: 📂 Reading file: /home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem
-2025-03-07T15:02:32.025212Z DEBUG qkd_client::reporter::qkd_client: ✅ Successfully read 2155 bytes
-2025-03-07T15:02:32.040960Z  INFO integration_test: 🔑 Retrieving quantum-secured key from QKD server
-2025-03-07T15:02:32.040992Z DEBUG qkd_client::reporter::qkd_client: Retrieving key from https://192.168.0.4/api/v1/keys/bobsae/enc_keys
-2025-03-07T15:02:32.041010Z DEBUG qkd_client::reporter::qkd_client: Sending request: KeyRequest { sae_id: "bobsae", key_size: 256, number_of_keys: 1 }
-2025-03-07T15:02:32.041323Z DEBUG hyper::client::connect::http: connecting to 192.168.0.4:443
-2025-03-07T15:02:32.041703Z DEBUG hyper::client::connect::http: connected to 192.168.0.4:443
-2025-03-07T15:02:32.057164Z DEBUG hyper::proto::h1::io: flushed 245 bytes
-2025-03-07T15:02:32.135778Z DEBUG hyper::proto::h1::io: parsed 5 headers
-2025-03-07T15:02:32.135812Z DEBUG hyper::proto::h1::conn: incoming body is content-length (113 bytes)
-2025-03-07T15:02:32.135874Z DEBUG hyper::proto::h1::conn: incoming body completed
-2025-03-07T15:02:32.135961Z DEBUG qkd_client::reporter::qkd_client: Response status: 200 OK
-2025-03-07T15:02:32.136160Z DEBUG hyper::client::pool: pooling idle connection for ("https", 192.168.0.4)
-2025-03-07T15:02:32.136364Z  INFO qkd_client::reporter::qkd_client: Successfully retrieved key with ID: ddad1439-eb04-415a-9e97-0acacbbb7e3f
-2025-03-07T15:02:32.136438Z  INFO integration_test: 🔑 Quantum key retrieved (32 bytes)
-2025-03-07T15:02:32.136473Z DEBUG qkd_client::quantum_auth::hybrid: Generating classical Ed25519 keypair
-2025-03-07T15:02:32.136641Z DEBUG qkd_client::quantum_auth::hybrid: Initializing quantum-resistant SPHINCS+ auth
-2025-03-07T15:02:32.136668Z DEBUG qkd_client::quantum_auth::pq::sphincs: Initializing SPHINCS+ authentication with variant SPHINCS+-SHA2-256f-simple (256-bit security)
-2025-03-07T15:02:32.136686Z  INFO qkd_client::quantum_auth::pq::sphincs: Using SPHINCS+ fast variant with 256-bit security (high security, recommended for long-term protection)
-2025-03-07T15:02:32.150237Z DEBUG qkd_client::quantum_auth::pq::sphincs: SPHINCS+ keypair generated in 13.533837ms
-2025-03-07T15:02:32.150304Z DEBUG qkd_client::quantum_auth::pq::sphincs:   Public key size: 64 bytes
-2025-03-07T15:02:32.150323Z DEBUG qkd_client::quantum_auth::pq::sphincs:   Secret key size: 128 bytes
-2025-03-07T15:02:32.150367Z DEBUG qkd_client::vrf::integrated_vrf: Generating VRF output
-2025-03-07T15:02:32.150397Z DEBUG qkd_client::vrf::core: Generating VRF output from quantum key, input length: 16
-2025-03-07T15:02:32.150494Z DEBUG qkd_client::vrf::core: Generated VRF seed from quantum key and input
-2025-03-07T15:02:32.150618Z DEBUG qkd_client::quantum_auth::hybrid: Generated classical Ed25519 signature in 104.51µs
-2025-03-07T15:02:32.150640Z DEBUG qkd_client::quantum_auth::pq::sphincs: Signing with SPHINCS+ (SPHINCS+-SHA2-256f-simple) - message size: 64B
-2025-03-07T15:02:32.452197Z DEBUG qkd_client::quantum_auth::pq::sphincs: Generated SPHINCS+ signature: 49905B in 298.036272ms
-2025-03-07T15:02:32.452229Z DEBUG qkd_client::quantum_auth::hybrid: Generated quantum SPHINCS+ signature in 301.588933ms
-2025-03-07T15:02:32.452246Z  INFO qkd_client::quantum_auth::hybrid: Hybrid signature generated - classical: 64B, quantum: 49905B, total time: 301.733349ms
-2025-03-07T15:02:32.456052Z DEBUG qkd_client::vrf::core: Serialized signature in 3.790666ms
-2025-03-07T15:02:32.485606Z  INFO qkd_client::vrf::core: VRF output generated successfully: 64 bytes, proof: 66660 bytes
-2025-03-07T15:02:32.485633Z DEBUG qkd_client::vrf::integrated_vrf: Generated VRF output in 335.237332ms
-2025-03-07T15:02:32.485669Z  INFO qkd_client::zk::circuit_manager: Generating proof for circuit: vrf_seed_proof
-2025-03-07T15:02:32.485884Z DEBUG qkd_client::zk::circuit_manager: Created input file at "/home/paraxiom/qkd_client/circuits/vrf_seed_proof_input.json"
-2025-03-07T15:02:32.485912Z  INFO qkd_client::zk::circuit_manager: Generating witness...
-2025-03-07T15:02:32.704119Z  INFO qkd_client::zk::circuit_manager: ✅ Generated witness successfully
-2025-03-07T15:02:32.704177Z  INFO qkd_client::zk::circuit_manager: Generating proof...
-2025-03-07T15:02:33.319500Z  INFO qkd_client::zk::circuit_manager: ✅ Generated proof successfully
-2025-03-07T15:02:33.319624Z  INFO qkd_client::vrf::integrated_vrf: VRF generation completed in 1.169226468s
-2025-03-07T15:02:33.319977Z  INFO integration_test: Wrote circuit input JSON to "/home/paraxiom/qkd_client/circuits/vrf_seed_proof_input.json"
-[INFO]  snarkJS: OK!
-2025-03-07T15:02:34.559373Z  INFO integration_test: ✅ ZK Proof verified successfully
-2025-03-07T15:02:34.559428Z DEBUG qkd_client::vrf::integrated_vrf: Verifying VRF output
-2025-03-07T15:02:34.559448Z DEBUG qkd_client::vrf::core: Verifying VRF output, input length: 16
-2025-03-07T15:02:34.564680Z DEBUG qkd_client::quantum_auth::hybrid: Classical signature verified in 295.175µs
-2025-03-07T15:02:34.564712Z DEBUG qkd_client::quantum_auth::pq::sphincs: Verifying SPHINCS+ signature - message size: 64B, signature size: 49905B
-2025-03-07T15:02:34.576531Z  INFO qkd_client::quantum_auth::pq::sphincs: ✅ SPHINCS+ signature verified successfully in 8.051782ms
-2025-03-07T15:02:34.576562Z DEBUG qkd_client::quantum_auth::hybrid: Quantum signature verified in 11.850084ms
-2025-03-07T15:02:34.576578Z  INFO qkd_client::quantum_auth::hybrid: Hybrid signature verified successfully in 12.200133ms
-2025-03-07T15:02:34.576594Z DEBUG qkd_client::vrf::core: VRF signature verified in 17.076307ms
-2025-03-07T15:02:34.606314Z  INFO qkd_client::vrf::core: VRF verification result: valid
-2025-03-07T15:02:34.606344Z  INFO qkd_client::vrf::integrated_vrf: VRF verification completed in 46.898001ms: true
-2025-03-07T15:02:34.606361Z  INFO integration_test: ✅ VRF verification successful
-paraxiom@paraxiom-VMware20-1:~/qkd_client$ 
diff --git a/src/bin/hybrid_auth.rs b/src/bin/hybrid_auth.rs
index d031443..e47bb53 100644
--- a/src/bin/hybrid_auth.rs
+++ b/src/bin/hybrid_auth.rs
@@ -22,30 +22,45 @@ async fn main() {
     let start = Instant::now();
     match HybridAuth::new() {
         Ok(auth) => {
-            info!("✅ Hybrid authentication initialized in {:?}", start.elapsed());
-            
+            info!(
+                "✅ Hybrid authentication initialized in {:?}",
+                start.elapsed()
+            );
+
             // Display key info
-            info!("Classical public key size: {} bytes", auth.get_classical_public_key().len());
-            info!("Quantum public key size: {} bytes", auth.get_quantum_public_key().len());
-            
+            info!(
+                "Classical public key size: {} bytes",
+                auth.get_classical_public_key().len()
+            );
+            info!(
+                "Quantum public key size: {} bytes",
+                auth.get_quantum_public_key().len()
+            );
+
             // Test with different message sizes
             let message_sizes = [32, 256, 1024, 4096];
-            
+
             for size in message_sizes {
                 // Create test message of this size
                 let message: Vec<u8> = (0..size).map(|i| (i % 256) as u8).collect();
                 info!("\nTesting with message size: {} bytes", size);
-                
+
                 // Sign the message
                 let start = Instant::now();
                 match auth.sign(&message) {
                     Ok(signature) => {
                         let sign_time = start.elapsed();
                         info!("✅ Hybrid signature generated in {:?}", sign_time);
-                        info!("   Classical signature: {} bytes", signature.classical.len());
+                        info!(
+                            "   Classical signature: {} bytes",
+                            signature.classical.len()
+                        );
                         info!("   Quantum signature: {} bytes", signature.quantum.len());
-                        info!("   Total size: {} bytes", signature.classical.len() + signature.quantum.len());
-                        
+                        info!(
+                            "   Total size: {} bytes",
+                            signature.classical.len() + signature.quantum.len()
+                        );
+
                         // Verify the signature
                         let start = Instant::now();
                         match auth.verify(&message, &signature) {
@@ -60,22 +75,27 @@ async fn main() {
                                 info!("❌ Error during verification: {}", e);
                             }
                         }
-                        
+
                         // Test serialization
                         match HybridAuth::serialize_signature(&signature) {
                             Ok(serialized) => {
                                 info!("   Serialized signature size: {} bytes", serialized.len());
-                                
+
                                 // Test deserialization
                                 match HybridAuth::deserialize_signature(&serialized) {
                                     Ok(deserialized) => {
                                         let start = Instant::now();
                                         match auth.verify(&message, &deserialized) {
                                             Ok(true) => {
-                                                info!("✅ Deserialized signature verified in {:?}", start.elapsed());
+                                                info!(
+                                                    "✅ Deserialized signature verified in {:?}",
+                                                    start.elapsed()
+                                                );
                                             }
                                             Ok(false) => {
-                                                info!("❌ Deserialized signature verification failed");
+                                                info!(
+                                                    "❌ Deserialized signature verification failed"
+                                                );
                                             }
                                             Err(e) => {
                                                 info!("❌ Error during verification: {}", e);
@@ -91,20 +111,25 @@ async fn main() {
                                 info!("❌ Error during serialization: {}", e);
                             }
                         }
-                        
+
                         // Try with tampered message (flip one bit)
                         let mut tampered = message.clone();
                         if !tampered.is_empty() {
                             tampered[0] ^= 0x01;
                         }
-                        
+
                         let start = Instant::now();
                         match auth.verify(&tampered, &signature) {
                             Ok(true) => {
-                                info!("❌ SECURITY ISSUE: Signature verified with tampered message!");
+                                info!(
+                                    "❌ SECURITY ISSUE: Signature verified with tampered message!"
+                                );
                             }
                             Ok(false) => {
-                                info!("✅ Security check passed: Tampered message rejected in {:?}", start.elapsed());
+                                info!(
+                                    "✅ Security check passed: Tampered message rejected in {:?}",
+                                    start.elapsed()
+                                );
                             }
                             Err(e) => {
                                 info!("❓ Verification of tampered message error: {}", e);
@@ -116,7 +141,7 @@ async fn main() {
                     }
                 }
             }
-            
+
             // Provide a summary
             info!("\n📊 Hybrid Authentication Summary:");
             info!("--------------------------------");
@@ -125,7 +150,7 @@ async fn main() {
             info!("✅ Combined security: Protected against both classical and quantum attacks");
             info!("✅ Pros: Full security during transition to post-quantum cryptography");
             info!("⚠️ Cons: Larger total signature size compared to classical-only");
-            
+
             info!("\n📋 Recommendation for QKD application:");
             info!("Use hybrid authentication for critical API requests");
             info!("Store signatures efficiently using binary format rather than Base64");
diff --git a/src/bin/integration_test.rs b/src/bin/integration_test.rs
index a0eaf16..ddbcc85 100644
--- a/src/bin/integration_test.rs
+++ b/src/bin/integration_test.rs
@@ -1,14 +1,14 @@
 //! Simplified QKD Client Integration Test
-//! 
+//!
 //! This test retrieves a quantum-secured key, uses it with a hybrid VRF to
 //! generate an output and proof, writes a JSON input for a Circom circuit, and
 //! then calls external commands (via snarkJS) to generate and verify a ZK proof.
 //!
 //! Note: The ZK proof generation currently uses a placeholder since a real
 //! implementation is not available yet.
+use qkd_client::quantum_auth::hybrid::HybridAuth;
 use qkd_client::reporter::QKDClient; // Adjust the import according to your project structure.
 use qkd_client::vrf::integrated_vrf::IntegratedVRF;
-use qkd_client::quantum_auth::hybrid::HybridAuth;
 use serde_json::json;
 use std::{error::Error, fs, path::PathBuf, process::Command};
 use tracing::{debug, info, Level};
@@ -30,7 +30,9 @@ fn ensure_verification_key(circuits_dir: &str) -> Result<(), Box<dyn Error>> {
         let status = Command::new("snarkjs")
             .current_dir(circuits_dir)
             .args(&[
-                "zkey", "export", "verificationkey",
+                "zkey",
+                "export",
+                "verificationkey",
                 "vrf_seed_proof_final.zkey",
                 "vrf_seed_proof_verification_key.json",
             ])
@@ -46,7 +48,9 @@ fn ensure_verification_key(circuits_dir: &str) -> Result<(), Box<dyn Error>> {
 #[tokio::main]
 async fn main() -> Result<(), Box<dyn Error>> {
     // Initialize logging.
-    let subscriber = FmtSubscriber::builder().with_max_level(Level::DEBUG).finish();
+    let subscriber = FmtSubscriber::builder()
+        .with_max_level(Level::DEBUG)
+        .finish();
     tracing::subscriber::set_global_default(subscriber)?;
     info!("🚀 Starting simplified QKD Client Integration Test");
 
@@ -55,18 +59,18 @@ async fn main() -> Result<(), Box<dyn Error>> {
     if !circuits_dir_path.exists() || !circuits_dir_path.is_dir() {
         return Err(format!("Circuits directory not found: {}", CIRCUITS_DIR).into());
     }
-    
+
     // Initialize QKD client and retrieve the quantum key.
     let qkd_client = QKDClient::new()?;
     info!("🔑 Retrieving quantum-secured key from QKD server");
     let key_bytes = qkd_client.get_key().await?; // Now returns Vec<u8>
     info!("🔑 Quantum key retrieved ({} bytes)", key_bytes.len());
-    
+
     // Initialize the hybrid VRF.
     let hybrid_auth = HybridAuth::new()?;
     // Use expect() to handle the Result properly
     let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
-    
+
     // Prepare input for VRF.
     let input = b"VRF test input for integration test";
     let mut input_padded = input.to_vec();
@@ -74,29 +78,32 @@ async fn main() -> Result<(), Box<dyn Error>> {
     input_padded.resize(16, 0);
     let mut quantum_key_padded = key_bytes.clone();
     quantum_key_padded.resize(16, 0);
-    
+
     // Generate VRF output and proof.
     let vrf_response = vrf.generate_with_proof(&input_padded, &quantum_key_padded)?;
     let mut vrf_seed_padded = vrf_response.output.clone();
     vrf_seed_padded.resize(16, 0);
-    
+
     // Build JSON input for the Circom circuit using hexadecimal strings.
     let circuit_input_json = json!({
         "inputData": bytes_to_hex_str(&input_padded),
         "quantumKey": bytes_to_hex_str(&quantum_key_padded),
         "vrfSeed": bytes_to_hex_str(&vrf_seed_padded)
     });
-    
+
     // Ensure the circuits directory is properly set up
     let circuit_input_path = circuits_dir_path.join("vrf_seed_proof_input.json");
-    fs::write(&circuit_input_path, serde_json::to_string_pretty(&circuit_input_json)?)?;
+    fs::write(
+        &circuit_input_path,
+        serde_json::to_string_pretty(&circuit_input_json)?,
+    )?;
     info!("Wrote circuit input JSON to {:?}", circuit_input_path);
-    
+
     // Check if the required files exist
     let wasm_path = circuits_dir_path.join("vrf_seed_proof_js/vrf_seed_proof.wasm");
     let js_path = circuits_dir_path.join("vrf_seed_proof_js/generate_witness.js");
     let zkey_path = circuits_dir_path.join("vrf_seed_proof_final.zkey");
-    
+
     if !wasm_path.exists() {
         return Err(format!("Required WASM file not found: {:?}", wasm_path).into());
     }
@@ -106,10 +113,10 @@ async fn main() -> Result<(), Box<dyn Error>> {
     if !zkey_path.exists() {
         return Err(format!("Required zkey file not found: {:?}", zkey_path).into());
     }
-    
+
     // Ensure that the verification key file exists.
     ensure_verification_key(CIRCUITS_DIR)?;
-    
+
     // Run witness generation using Node.js.
     info!("Running witness generation...");
     let witness_status = Command::new("node")
@@ -121,45 +128,49 @@ async fn main() -> Result<(), Box<dyn Error>> {
             "vrf_seed_proof_witness.wtns",
         ])
         .status()?;
-    
+
     if !witness_status.success() {
         return Err("❌ Witness generation failed".into());
     }
     info!("✅ Witness generation successful");
-    
+
     // Run proof generation using snarkJS.
     info!("Running proof generation...");
     let proof_status = Command::new("snarkjs")
         .current_dir(&circuits_dir_path)
         .args(&[
-            "groth16", "prove", "vrf_seed_proof_final.zkey",
+            "groth16",
+            "prove",
+            "vrf_seed_proof_final.zkey",
             "vrf_seed_proof_witness.wtns",
             "vrf_seed_proof_proof.json",
             "vrf_seed_proof_public.json",
         ])
         .status()?;
-    
+
     if !proof_status.success() {
         return Err("❌ ZK Proof generation failed".into());
     }
     info!("✅ Proof generation successful");
-    
+
     // Verify the proof using snarkJS.
     info!("Running proof verification...");
     let verify_status = Command::new("snarkjs")
         .current_dir(&circuits_dir_path)
         .args(&[
-            "groth16", "verify", "vrf_seed_proof_verification_key.json",
+            "groth16",
+            "verify",
+            "vrf_seed_proof_verification_key.json",
             "vrf_seed_proof_public.json",
             "vrf_seed_proof_proof.json",
         ])
         .status()?;
-    
+
     if !verify_status.success() {
         return Err("❌ ZK Proof verification failed".into());
     }
     info!("✅ ZK Proof verified successfully");
-    
+
     // Finally, verify the VRF output using our integrated VRF.
     info!("Verifying VRF output...");
     let valid = vrf.verify_with_proof(&input_padded, &vrf_response, &quantum_key_padded)?;
@@ -169,4 +180,4 @@ async fn main() -> Result<(), Box<dyn Error>> {
     } else {
         Err("❌ VRF verification failed".into())
     }
-}
\ No newline at end of file
+}
diff --git a/src/bin/quantum_security_test.rs b/src/bin/quantum_security_test.rs
index ef9c618..9ac3a78 100644
--- a/src/bin/quantum_security_test.rs
+++ b/src/bin/quantum_security_test.rs
@@ -4,11 +4,12 @@ use qkd_client::vrf::integrated_vrf::IntegratedVRF;
 use reqwest::{Certificate, Client, Identity};
 use serde::{Deserialize, Serialize};
 use std::error::Error;
-use tracing::{info, debug, Level};
+use tracing::{debug, info, Level};
 use tracing_subscriber::FmtSubscriber;
 
 const BASE_URL: &str = "https://192.168.0.4";
-const ALICE_CERT_PATH: &str = "/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12";
+const ALICE_CERT_PATH: &str =
+    "/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12";
 const CA_CERT_PATH: &str = "/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem";
 const P12_PASSWORD: &str = "MySecret";
 
@@ -45,7 +46,11 @@ impl QKDClient {
         })
     }
 
-    pub async fn get_key(&self, sae_id: &str, key_size: u32) -> Result<(String, Vec<u8>), Box<dyn Error>> {
+    pub async fn get_key(
+        &self,
+        sae_id: &str,
+        key_size: u32,
+    ) -> Result<(String, Vec<u8>), Box<dyn Error>> {
         let req_body = serde_json::json!({
             "sae_id": sae_id,
             "key_size": key_size,
@@ -66,44 +71,46 @@ impl QKDClient {
 
 #[tokio::main]
 async fn main() -> Result<(), Box<dyn Error>> {
-    let subscriber = FmtSubscriber::builder().with_max_level(Level::INFO).finish();
+    let subscriber = FmtSubscriber::builder()
+        .with_max_level(Level::INFO)
+        .finish();
     tracing::subscriber::set_global_default(subscriber)?;
-    
+
     info!("🚀 Starting QKD Client Integration Test");
-    
+
     let qkd_client = QKDClient::new()?;
     info!("🔑 Requesting quantum-secured key from QKD server");
     let (key_id, key_bytes) = qkd_client.get_key("bobsae", 256).await?;
     info!("🔑 Retrieved key ID: {}", key_id);
-    
+
     info!("🛡️ Testing Quantum-Resistant VRF");
-    
+
     // Create the hybrid auth
     let hybrid_auth = HybridAuth::new()?;
-    
+
     // Create the VRF - unwrap once
     let vrf = IntegratedVRF::new(hybrid_auth).expect("Failed to create IntegratedVRF");
-    
+
     // Prepare input data
     let input_data = b"Integration test for QKD quantum-resistant VRF";
-    
+
     // Generate VRF output and proof
     let vrf_response = vrf.generate_with_proof(input_data, &key_bytes)?;
-    
+
     info!(
         "VRF Output: {} bytes, Proof: {} bytes",
         vrf_response.output.len(),
         vrf_response.vrf_proof.len()
     );
-    
+
     // Verify the VRF output
     let is_valid = vrf.verify_with_proof(input_data, &vrf_response, &key_bytes)?;
-    
+
     if is_valid {
         info!("✅ VRF verification successful");
     } else {
         return Err("❌ VRF verification failed".into());
     }
-    
+
     Ok(())
-}
\ No newline at end of file
+}
diff --git a/src/bin/stand_alone_integration.rs b/src/bin/stand_alone_integration.rs
index 2246cb9..c487a76 100644
--- a/src/bin/stand_alone_integration.rs
+++ b/src/bin/stand_alone_integration.rs
@@ -12,35 +12,36 @@ use std::time::Duration;
 #[tokio::main]
 async fn main() -> Result<(), Box<dyn Error>> {
     println!("Starting QKD client certificate test");
-    
+
     // Use absolute paths exactly as in your working reporter code
-    let p12_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
+    let p12_path =
+        Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
     let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
-    
+
     println!("Loading certificates...");
-    
+
     // Read the PKCS#12
     let mut pkcs12_file = File::open(p12_path)?;
     let mut pkcs12_data = Vec::new();
     pkcs12_file.read_to_end(&mut pkcs12_data)?;
     println!("PKCS#12 file read: {} bytes", pkcs12_data.len());
-    
+
     // Read the CA certificate
     let mut ca_file = File::open(ca_path)?;
     let mut ca_data = Vec::new();
     ca_file.read_to_end(&mut ca_data)?;
     println!("CA certificate file read: {} bytes", ca_data.len());
-    
+
     // Parse the PKCS#12 data
     let identity = Identity::from_pkcs12_der(&pkcs12_data, "MySecret")?;
     println!("Successfully created Identity from PKCS#12");
-    
-    // Parse the CA certificate 
+
+    // Parse the CA certificate
     let ca_cert = match Certificate::from_pem(&ca_data) {
         Ok(cert) => {
             println!("Successfully created Certificate from PEM");
             cert
-        },
+        }
         Err(e) => {
             println!("Failed to parse certificate as PEM: {}", e);
             println!("Trying DER format...");
@@ -48,7 +49,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
                 Ok(cert) => {
                     println!("Successfully created Certificate from DER");
                     cert
-                },
+                }
                 Err(e) => {
                     println!("Failed to parse certificate as DER: {}", e);
                     return Err("Failed to parse CA certificate".into());
@@ -56,7 +57,7 @@ async fn main() -> Result<(), Box<dyn Error>> {
             }
         }
     };
-    
+
     // Create the client
     println!("Building HTTP client...");
     let client = Client::builder()
@@ -66,26 +67,26 @@ async fn main() -> Result<(), Box<dyn Error>> {
         .danger_accept_invalid_hostnames(true)
         .timeout(Duration::from_secs(5))
         .build()?;
-    
+
     println!("Successfully built client with certificates");
-    
+
     // Try a simple GET request to test the client
     println!("Testing client with a request...");
     let url = "https://192.168.0.4/api/v1/status";
     let response = client.get(url).send().await;
-    
+
     match response {
         Ok(resp) => {
             println!("Request successful! Status: {}", resp.status());
             if resp.status().is_success() {
                 println!("Response body: {}", resp.text().await?);
             }
-        },
+        }
         Err(e) => {
             println!("Request failed: {}", e);
         }
     }
-    
+
     println!("Certificate test complete");
     Ok(())
 }
diff --git a/src/bin/zk_integration_test.rs b/src/bin/zk_integration_test.rs
index 5cac26e..264f237 100644
--- a/src/bin/zk_integration_test.rs
+++ b/src/bin/zk_integration_test.rs
@@ -203,4 +203,4 @@ async fn main() -> Result<(), Box<dyn Error>> {
     
     info!("ZK integration test completed successfully");
     Ok(())
-}
\ No newline at end of file
+}
diff --git a/src/byzantine/vrf_consensus.rs b/src/byzantine/vrf_consensus.rs
index 3f72921..49f3882 100644
--- a/src/byzantine/vrf_consensus.rs
+++ b/src/byzantine/vrf_consensus.rs
@@ -156,7 +156,8 @@ mod tests {
         let auth = HybridAuth::new()?;
         let vrf = IntegratedVRF::new(auth);
         let quantum_key = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
-        let consensus = VRFBasedConsensus::new(vrf.expect("Failed to create IntegratedVRF"), 1, quantum_key);
+        let consensus =
+            VRFBasedConsensus::new(vrf.expect("Failed to create IntegratedVRF"), 1, quantum_key);
 
         // Test participants
         let participants = vec![10, 20, 30, 40, 50];
diff --git a/src/lib.rs b/src/lib.rs
index af16f94..6097871 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -5,3 +5,18 @@ pub mod quantum_auth;
 pub mod reporter;
 pub mod vrf;
 pub mod zk;
+
+// Re-export QKDClient so it appears at crate root
+pub use crate::reporter::QKDClient;
+
+pub fn get_quantum_random_bytes(num_bytes: usize) -> Result<Vec<u8>, String> {
+    let rt = tokio::runtime::Runtime::new()
+        .map_err(|e| format!("Failed to create tokio runtime: {e}"))?;
+    rt.block_on(async move {
+        // now this will work:
+        let client = crate::QKDClient::new()
+            .map_err(|e| format!("QKDClient creation error: {e}"))?;
+        // ...
+        Ok(vec![])
+    })
+}
diff --git a/src/qkd/etsi_api.rs b/src/qkd/etsi_api.rs
index a116563..e40623b 100644
--- a/src/qkd/etsi_api.rs
+++ b/src/qkd/etsi_api.rs
@@ -1,5 +1,5 @@
 // src/qkd/etsi_api.rs
-use reqwest::{Client, Certificate, StatusCode};
+use reqwest::{Certificate, Client, StatusCode};
 use serde::{Deserialize, Serialize};
 use std::error::Error;
 use std::fs;
@@ -28,8 +28,8 @@ pub struct QKDKey {
 
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct KeyMetadata {
-    pub source: String,  // "toshiba", "idq", etc.
-    pub qber: f32,       // Quantum Bit Error Rate
+    pub source: String, // "toshiba", "idq", etc.
+    pub qber: f32,      // Quantum Bit Error Rate
     pub key_size: usize,
     pub status: KeyStatus,
 }
@@ -93,7 +93,7 @@ pub struct ETSIClient {
 
 impl ETSIClient {
     /// Create a new ETSI QKD client
-    /// 
+    ///
     /// # Arguments
     /// * `device_type` - Type of QKD device (Toshiba, IDQ, etc.)
     /// * `side` - The side of the QKD device (Alice or Bob)
@@ -101,11 +101,11 @@ impl ETSIClient {
     /// * `root_cert_path` - Optional path to root CA certificate
     /// * `auth_token` - Optional authentication token for API access
     pub fn new(
-        device_type: DeviceType, 
-        side: Side, 
-        cert_path: &Path, 
+        device_type: DeviceType,
+        side: Side,
+        cert_path: &Path,
         root_cert_path: Option<&Path>,
-        auth_token: Option<String>
+        auth_token: Option<String>,
     ) -> Result<Self, Box<dyn Error>> {
         let base_url = match device_type {
             DeviceType::Toshiba => match side {
@@ -122,9 +122,9 @@ impl ETSIClient {
             },
             DeviceType::Simulated => "http://localhost:8000/api/v1",
         };
-        
+
         let mut client_builder = Client::builder();
-        
+
         // Load certificate if needed and if the path exists
         if matches!(device_type, DeviceType::Simulated) {
             debug!("Using simulated device, skipping certificate loading");
@@ -137,7 +137,7 @@ impl ETSIClient {
                 let cert_data = fs::read(cert_path)?;
                 let cert = Certificate::from_pem(&cert_data)?;
                 client_builder = client_builder.add_root_certificate(cert);
-                
+
                 // Load root certificate if provided
                 if let Some(root_path) = root_cert_path {
                     if root_path.exists() {
@@ -150,18 +150,21 @@ impl ETSIClient {
                     }
                 }
             } else {
-                warn!("Certificate path {:?} does not exist, proceeding without certificate", cert_path);
+                warn!(
+                    "Certificate path {:?} does not exist, proceeding without certificate",
+                    cert_path
+                );
             }
-            
+
             // For real devices, we may need to disable certificate verification if there are issues
             // with self-signed certificates or complex certificate chains
             // Uncomment this line if you're having certificate verification issues
             // client_builder = client_builder.danger_accept_invalid_certs(true);
         }
-        
+
         // Create client with certificate
         let client = client_builder.build()?;
-            
+
         Ok(Self {
             base_url: base_url.to_string(),
             client,
@@ -170,7 +173,7 @@ impl ETSIClient {
             key_cache: Arc::new(Mutex::new(Vec::new())),
         })
     }
-    
+
     /// Request a QKD key from Alice's side
     /// This method requests a new quantum key from the QKD device
     ///
@@ -178,25 +181,34 @@ impl ETSIClient {
     /// * `key_size` - Size of the requested key in bytes
     /// * `dest_id` - Destination ID (Bob's identifier)
     /// * `sae_id` - Optional SAE (Secure Authentication Encapsulation) ID
-    pub async fn get_key_alice(&self, key_size: usize, dest_id: &str, sae_id: Option<&str>) -> Result<QKDKey, Box<dyn Error>> {
-        debug!("Requesting key from Alice's side, size: {} bytes, destination: {}", key_size, dest_id);
-        
+    pub async fn get_key_alice(
+        &self,
+        key_size: usize,
+        dest_id: &str,
+        sae_id: Option<&str>,
+    ) -> Result<QKDKey, Box<dyn Error>> {
+        debug!(
+            "Requesting key from Alice's side, size: {} bytes, destination: {}",
+            key_size, dest_id
+        );
+
         // Check key cache first
         {
             let cache = self.key_cache.lock().await;
             for key in cache.iter() {
-                if key.metadata.key_size >= key_size && key.metadata.status == KeyStatus::Available {
+                if key.metadata.key_size >= key_size && key.metadata.status == KeyStatus::Available
+                {
                     debug!("Found suitable key in cache: {}", key.key_id);
                     return Ok(key.clone());
                 }
             }
         }
-        
+
         // For simulated device, generate a simulated key instead of making HTTP request
         if matches!(self.device_type, DeviceType::Simulated) {
             return self.generate_simulated_key(key_size, dest_id, None).await;
         }
-        
+
         // Prepare request based on device type
         let endpoint = match self.device_type {
             DeviceType::Toshiba => format!("{}/keys/request", self.base_url),
@@ -204,7 +216,7 @@ impl ETSIClient {
             DeviceType::Basejump => format!("{}/key-management/keys", self.base_url),
             DeviceType::Simulated => format!("{}/keys", self.base_url),
         };
-        
+
         // Build request payload
         let request = KeyRequest {
             requested_key_size: key_size,
@@ -213,32 +225,32 @@ impl ETSIClient {
             key_expansion_algorithm: "none".to_string(), // No expansion by default
             metadata: None,
         };
-        
+
         // Build request with authentication if provided
         let mut req_builder = self.client.post(&endpoint).json(&request);
         if let Some(token) = &self.auth_token {
             req_builder = req_builder.header("Authorization", format!("Bearer {}", token));
         }
-        
+
         // Send request
         let response = req_builder.send().await?;
-        
+
         // Handle response
         match response.status() {
             StatusCode::OK | StatusCode::CREATED => {
                 let key_response: KeyResponse = response.json().await?;
-                
+
                 // Handle case where key might be pending
                 if key_response.status == "pending" {
                     debug!("Key generation is pending, polling for status");
                     return self.poll_key_status(&key_response.key_id, 10, 1000).await;
                 }
-                
+
                 // Process the key response
                 if let Some(key_b64) = key_response.key {
                     let key_bytes = base64::decode(&key_b64)?;
                     let key_size = key_bytes.len();
-                    
+
                     let qkd_key = QKDKey {
                         key_id: key_response.key_id,
                         key_bytes,
@@ -250,24 +262,31 @@ impl ETSIClient {
                             status: KeyStatus::Available,
                         },
                     };
-                    
+
                     // Add to cache
                     {
                         let mut cache = self.key_cache.lock().await;
                         cache.push(qkd_key.clone());
-                        
+
                         // Limit cache size
                         if cache.len() > 50 {
                             cache.remove(0);
                         }
                     }
-                    
-                    info!("Successfully retrieved key: {}, size: {}", qkd_key.key_id, qkd_key.metadata.key_size);
+
+                    info!(
+                        "Successfully retrieved key: {}, size: {}",
+                        qkd_key.key_id, qkd_key.metadata.key_size
+                    );
                     Ok(qkd_key)
                 } else {
-                    Err(format!("No key material in response for key_id: {}", key_response.key_id).into())
+                    Err(format!(
+                        "No key material in response for key_id: {}",
+                        key_response.key_id
+                    )
+                    .into())
                 }
-            },
+            }
             status => {
                 let error_text = response.text().await?;
                 error!("Error retrieving key: {}", error_text);
@@ -275,7 +294,7 @@ impl ETSIClient {
             }
         }
     }
-    
+
     /// Retrieve a QKD key from Bob's side
     /// This method retrieves a quantum key that was previously distributed by Alice
     ///
@@ -283,7 +302,7 @@ impl ETSIClient {
     /// * `key_id` - ID of the key to retrieve
     pub async fn get_key_bob(&self, key_id: &str) -> Result<QKDKey, Box<dyn Error>> {
         debug!("Retrieving key from Bob's side, key_id: {}", key_id);
-        
+
         // Check key cache first
         {
             let cache = self.key_cache.lock().await;
@@ -294,17 +313,17 @@ impl ETSIClient {
                 }
             }
         }
-        
+
         // For simulated device, regenerate the same key deterministically
         if matches!(self.device_type, DeviceType::Simulated) {
             // Parse the key_id to extract the necessary information
             // The key_id format is expected to be: "{dest_id}-{key_size}-{uuid}"
             let parts: Vec<&str> = key_id.split('-').collect();
-            
+
             if parts.len() >= 3 {
                 // Extract the destination ID and key size from the key_id
                 let mut dest_id = parts[0].to_string();
-                
+
                 // If there are more than 3 parts, the destination ID might contain hyphens
                 // We need to reconstruct it properly
                 if parts.len() > 3 {
@@ -313,21 +332,28 @@ impl ETSIClient {
                     let size_index = parts.len() - 2;
                     dest_id = parts[0..size_index].join("-");
                     let key_size = parts[size_index].parse::<usize>().unwrap_or(32);
-                    
+
                     // Use the exact key_id to ensure deterministic generation
-                    return self.generate_simulated_key(key_size, &dest_id, Some(key_id)).await;
+                    return self
+                        .generate_simulated_key(key_size, &dest_id, Some(key_id))
+                        .await;
                 } else {
                     // Simple case: destination-size-uuid
                     let key_size = parts[1].parse::<usize>().unwrap_or(32);
-                    return self.generate_simulated_key(key_size, &dest_id, Some(key_id)).await;
+                    return self
+                        .generate_simulated_key(key_size, &dest_id, Some(key_id))
+                        .await;
                 }
             } else {
                 // Fallback for malformed key_ids
-                warn!("Malformed key_id format: {}, using as destination with default size", key_id);
+                warn!(
+                    "Malformed key_id format: {}, using as destination with default size",
+                    key_id
+                );
                 return self.generate_simulated_key(32, key_id, Some(key_id)).await;
             }
         }
-        
+
         // Prepare request based on device type
         let endpoint = match self.device_type {
             DeviceType::Toshiba => format!("{}/keys/{}", self.base_url, key_id),
@@ -335,25 +361,25 @@ impl ETSIClient {
             DeviceType::Basejump => format!("{}/key-management/keys/{}", self.base_url, key_id),
             DeviceType::Simulated => format!("{}/keys/{}", self.base_url, key_id),
         };
-        
+
         // Build request with authentication if provided
         let mut req_builder = self.client.get(&endpoint);
         if let Some(token) = &self.auth_token {
             req_builder = req_builder.header("Authorization", format!("Bearer {}", token));
         }
-        
+
         // Send request
         let response = req_builder.send().await?;
-        
+
         // Handle response
         match response.status() {
             StatusCode::OK => {
                 let key_response: KeyResponse = response.json().await?;
-                
+
                 if let Some(key_b64) = key_response.key {
                     let key_bytes = base64::decode(&key_b64)?;
                     let key_size = key_bytes.len();
-                    
+
                     let qkd_key = QKDKey {
                         key_id: key_response.key_id,
                         key_bytes,
@@ -365,27 +391,32 @@ impl ETSIClient {
                             status: KeyStatus::Available,
                         },
                     };
-                    
+
                     // Add to cache
                     {
                         let mut cache = self.key_cache.lock().await;
                         cache.push(qkd_key.clone());
-                        
+
                         // Limit cache size
                         if cache.len() > 50 {
                             cache.remove(0);
                         }
                     }
-                    
-                    info!("Successfully retrieved Bob's key: {}, size: {}", qkd_key.key_id, qkd_key.metadata.key_size);
+
+                    info!(
+                        "Successfully retrieved Bob's key: {}, size: {}",
+                        qkd_key.key_id, qkd_key.metadata.key_size
+                    );
                     Ok(qkd_key)
                 } else {
-                    Err(format!("No key material in response for key_id: {}", key_response.key_id).into())
+                    Err(format!(
+                        "No key material in response for key_id: {}",
+                        key_response.key_id
+                    )
+                    .into())
                 }
-            },
-            StatusCode::NOT_FOUND => {
-                Err(format!("Key not found: {}", key_id).into())
-            },
+            }
+            StatusCode::NOT_FOUND => Err(format!("Key not found: {}", key_id).into()),
             status => {
                 let error_text = response.text().await?;
                 error!("Error retrieving key: {}", error_text);
@@ -393,14 +424,14 @@ impl ETSIClient {
             }
         }
     }
-    
+
     /// Check the status of a key
-    /// 
+    ///
     /// # Arguments
     /// * `key_id` - ID of the key to check
     pub async fn check_key_status(&self, key_id: &str) -> Result<KeyStatus, Box<dyn Error>> {
         debug!("Checking status for key: {}", key_id);
-        
+
         // For simulated device, check our cache
         if matches!(self.device_type, DeviceType::Simulated) {
             let cache = self.key_cache.lock().await;
@@ -411,29 +442,31 @@ impl ETSIClient {
             }
             return Err(format!("Simulated key not found: {}", key_id).into());
         }
-        
+
         // Prepare request based on device type
         let endpoint = match self.device_type {
             DeviceType::Toshiba => format!("{}/keys/{}/status", self.base_url, key_id),
             DeviceType::IDQ => format!("{}/sae/keys/{}/status", self.base_url, key_id),
-            DeviceType::Basejump => format!("{}/key-management/keys/{}/status", self.base_url, key_id),
+            DeviceType::Basejump => {
+                format!("{}/key-management/keys/{}/status", self.base_url, key_id)
+            }
             DeviceType::Simulated => format!("{}/keys/{}/status", self.base_url, key_id),
         };
-        
+
         // Build request with authentication if provided
         let mut req_builder = self.client.get(&endpoint);
         if let Some(token) = &self.auth_token {
             req_builder = req_builder.header("Authorization", format!("Bearer {}", token));
         }
-        
+
         // Send request
         let response = req_builder.send().await?;
-        
+
         // Handle response
         match response.status() {
             StatusCode::OK => {
                 let status_response: KeyStatusResponse = response.json().await?;
-                
+
                 // Map API status to our enum
                 let key_status = match status_response.status.as_str() {
                     "available" => KeyStatus::Available,
@@ -442,7 +475,7 @@ impl ETSIClient {
                     "expired" => KeyStatus::Expired,
                     s => KeyStatus::Error(s.to_string()),
                 };
-                
+
                 // Update cache if needed
                 {
                     let mut cache = self.key_cache.lock().await;
@@ -453,13 +486,11 @@ impl ETSIClient {
                         }
                     }
                 }
-                
+
                 info!("Key status for {}: {:?}", key_id, key_status);
                 Ok(key_status)
-            },
-            StatusCode::NOT_FOUND => {
-                Err(format!("Key not found: {}", key_id).into())
-            },
+            }
+            StatusCode::NOT_FOUND => Err(format!("Key not found: {}", key_id).into()),
             status => {
                 let error_text = response.text().await?;
                 error!("Error checking key status: {}", error_text);
@@ -467,7 +498,7 @@ impl ETSIClient {
             }
         }
     }
-    
+
     /// Delete a key from the QKD device
     /// This is important for security to ensure keys are only used once
     ///
@@ -475,7 +506,7 @@ impl ETSIClient {
     /// * `key_id` - ID of the key to delete
     pub async fn delete_key(&self, key_id: &str) -> Result<bool, Box<dyn Error>> {
         debug!("Deleting key: {}", key_id);
-        
+
         // For simulated device, just remove from cache
         if matches!(self.device_type, DeviceType::Simulated) {
             // Update cache
@@ -493,7 +524,7 @@ impl ETSIClient {
                 }
             }
         }
-        
+
         // Prepare request based on device type
         let endpoint = match self.device_type {
             DeviceType::Toshiba => format!("{}/keys/{}", self.base_url, key_id),
@@ -501,16 +532,16 @@ impl ETSIClient {
             DeviceType::Basejump => format!("{}/key-management/keys/{}", self.base_url, key_id),
             DeviceType::Simulated => format!("{}/keys/{}", self.base_url, key_id),
         };
-        
+
         // Build request with authentication if provided
         let mut req_builder = self.client.delete(&endpoint);
         if let Some(token) = &self.auth_token {
             req_builder = req_builder.header("Authorization", format!("Bearer {}", token));
         }
-        
+
         // Send request
         let response = req_builder.send().await?;
-        
+
         // Handle response
         match response.status() {
             StatusCode::OK | StatusCode::NO_CONTENT => {
@@ -519,14 +550,14 @@ impl ETSIClient {
                     let mut cache = self.key_cache.lock().await;
                     cache.retain(|k| k.key_id != key_id);
                 }
-                
+
                 info!("Successfully deleted key: {}", key_id);
                 Ok(true)
-            },
+            }
             StatusCode::NOT_FOUND => {
                 warn!("Key not found for deletion: {}", key_id);
                 Ok(false)
-            },
+            }
             status => {
                 let error_text = response.text().await?;
                 error!("Error deleting key: {}", error_text);
@@ -534,53 +565,60 @@ impl ETSIClient {
             }
         }
     }
-    
+
     /// Poll for key status until it becomes available or times out
     ///
     /// # Arguments
     /// * `key_id` - ID of the key to poll
     /// * `max_attempts` - Maximum number of polling attempts
     /// * `delay_ms` - Delay between polling attempts in milliseconds
-    async fn poll_key_status(&self, key_id: &str, max_attempts: u32, delay_ms: u64) -> Result<QKDKey, Box<dyn Error>> {
+    async fn poll_key_status(
+        &self,
+        key_id: &str,
+        max_attempts: u32,
+        delay_ms: u64,
+    ) -> Result<QKDKey, Box<dyn Error>> {
         for attempt in 1..=max_attempts {
             debug!("Polling key status, attempt {}/{}", attempt, max_attempts);
-            
+
             // Check key status
             let status = self.check_key_status(key_id).await?;
-            
+
             match status {
                 KeyStatus::Available => {
                     // Key is ready, retrieve it
                     return self.get_key_bob(key_id).await;
-                },
+                }
                 KeyStatus::Pending => {
                     // Key is still being generated, wait and retry
                     tokio::time::sleep(tokio::time::Duration::from_millis(delay_ms)).await;
                     continue;
-                },
+                }
                 KeyStatus::Consumed | KeyStatus::Expired => {
-                    return Err(format!("Key {} is no longer available: {:?}", key_id, status).into());
-                },
+                    return Err(
+                        format!("Key {} is no longer available: {:?}", key_id, status).into(),
+                    );
+                }
                 KeyStatus::Error(e) => {
                     return Err(format!("Key error: {}", e).into());
-                },
+                }
             }
         }
-        
+
         Err(format!("Timed out waiting for key {} to become available", key_id).into())
     }
-    
+
     /// Get available key size from the QKD device
     /// This method queries the QKD device for the amount of key material available
     pub async fn get_available_key_size(&self) -> Result<usize, Box<dyn Error>> {
         debug!("Checking available key size");
-        
+
         // For simulated device, just return a standard value
         if matches!(self.device_type, DeviceType::Simulated) {
             info!("Simulated device returning default available key size of 1024 bytes");
             return Ok(1024); // Return a default value for simulated devices
         }
-        
+
         // Prepare request based on device type
         let endpoint = match self.device_type {
             DeviceType::Toshiba => format!("{}/keys/available", self.base_url),
@@ -588,54 +626,69 @@ impl ETSIClient {
             DeviceType::Basejump => format!("{}/key-management/status", self.base_url),
             DeviceType::Simulated => format!("{}/status", self.base_url),
         };
-        
+
         // Build request with authentication if provided
         let mut req_builder = self.client.get(&endpoint);
         if let Some(token) = &self.auth_token {
             req_builder = req_builder.header("Authorization", format!("Bearer {}", token));
         }
-        
+
         // Send request
         let response = req_builder.send().await?;
-        
+
         // Handle response
         match response.status() {
             StatusCode::OK => {
                 let status: serde_json::Value = response.json().await?;
-                
+
                 // Extract available key size from response (format varies by device)
                 let available_size = match self.device_type {
                     DeviceType::Toshiba => status["available_bytes"].as_u64().unwrap_or(0) as usize,
-                    DeviceType::IDQ => status["key_pool"]["available_bytes"].as_u64().unwrap_or(0) as usize,
-                    DeviceType::Basejump => status["available_key_bytes"].as_u64().unwrap_or(0) as usize,
-                    DeviceType::Simulated => status["available_bytes"].as_u64().unwrap_or(1024) as usize,
+                    DeviceType::IDQ => {
+                        status["key_pool"]["available_bytes"].as_u64().unwrap_or(0) as usize
+                    }
+                    DeviceType::Basejump => {
+                        status["available_key_bytes"].as_u64().unwrap_or(0) as usize
+                    }
+                    DeviceType::Simulated => {
+                        status["available_bytes"].as_u64().unwrap_or(1024) as usize
+                    }
                 };
-                
+
                 info!("Available key material: {} bytes", available_size);
                 Ok(available_size)
-            },
+            }
             status => {
                 let error_text = response.text().await?;
                 error!("Error checking available key size: {}", error_text);
-                Err(format!("Error checking available key size: {} - {}", status, error_text).into())
+                Err(format!(
+                    "Error checking available key size: {} - {}",
+                    status, error_text
+                )
+                .into())
             }
         }
     }
-    
+
     /// Clear the key cache
     pub async fn clear_cache(&self) {
         let mut cache = self.key_cache.lock().await;
         cache.clear();
         debug!("Key cache cleared");
     }
-    
+
     /// Generate a simulated QKD key for testing
     ///
     /// # Arguments
     /// * `key_size` - Size of the requested key in bytes
     /// * `dest_id` - Destination ID
     /// * `specific_key_id` - If provided, use this exact key ID instead of generating a new one
-    async fn generate_simulated_key(&self, key_size: usize, dest_id: &str, specific_key_id: Option<&str>) -> Result<QKDKey, Box<dyn Error>> {
+    async fn generate_simulated_key(
+        &self,
+        key_size: usize,
+        dest_id: &str,
+        specific_key_id: Option<&str>,
+    ) -> Result<QKDKey, Box<dyn Error>> {
         // Create key ID
         let key_id = if let Some(id) = specific_key_id {
             id.to_string()
@@ -643,31 +696,39 @@ impl ETSIClient {
             let unique_id = format!("{}-{}", dest_id, key_size);
             format!("{}-{}", unique_id, uuid::Uuid::new_v4())
         };
-        
+
         // Generate key bytes using a FULLY deterministic algorithm based on the key_id
         // This ensures that both Alice and Bob will get the same key for the same key_id
         let seed = if let Some(id) = specific_key_id {
             // If a specific key ID is provided, use it as the seed to ensure consistency
-            id.as_bytes().iter().fold(0u64, |acc, &x| acc.wrapping_add(x as u64))
+            id.as_bytes()
+                .iter()
+                .fold(0u64, |acc, &x| acc.wrapping_add(x as u64))
         } else {
             // Otherwise use key_id which contains the UUID
-            key_id.as_bytes().iter().fold(0u64, |acc, &x| acc.wrapping_add(x as u64))
+            key_id
+                .as_bytes()
+                .iter()
+                .fold(0u64, |acc, &x| acc.wrapping_add(x as u64))
         };
-        
+
         // Generate deterministic key bytes using the seed
         let mut key_bytes = vec![0u8; key_size];
         for i in 0..key_size {
             // Use a simple deterministic algorithm based on the seed
-            let value = ((seed.wrapping_add(i as u64)).wrapping_mul(0x5DEECE66Du64).wrapping_add(0xBu64)) % 256;
+            let value = ((seed.wrapping_add(i as u64))
+                .wrapping_mul(0x5DEECE66Du64)
+                .wrapping_add(0xBu64))
+                % 256;
             key_bytes[i] = value as u8;
         }
-        
+
         // Create simulated key
         let now = std::time::SystemTime::now()
             .duration_since(std::time::UNIX_EPOCH)
             .unwrap_or_default()
             .as_secs();
-        
+
         let qkd_key = QKDKey {
             key_id: key_id.clone(),
             key_bytes,
@@ -679,18 +740,18 @@ impl ETSIClient {
                 status: KeyStatus::Available,
             },
         };
-        
+
         // Add to cache
         {
             let mut cache = self.key_cache.lock().await;
             cache.push(qkd_key.clone());
-            
+
             // Limit cache size
             if cache.len() > 50 {
                 cache.remove(0);
             }
         }
-        
+
         info!("Generated simulated key: {}, size: {}", key_id, key_size);
         Ok(qkd_key)
     }
@@ -701,7 +762,7 @@ impl ETSIClient {
 mod tests {
     use super::*;
     use std::path::PathBuf;
-    
+
     #[tokio::test]
     async fn test_simulated_device() -> Result<(), Box<dyn Error>> {
         // Create client with simulated device
@@ -710,15 +771,15 @@ mod tests {
             Side::Alice,
             &PathBuf::from("nonexistent-cert.pem"),
             None,
-            None
+            None,
         )?;
-        
+
         // Just test that we can create the client
         assert_eq!(client.base_url, "http://localhost:8000/api/v1");
-        
+
         Ok(())
     }
-    
+
     #[tokio::test]
     async fn test_key_cache() -> Result<(), Box<dyn Error>> {
         // Create client
@@ -727,9 +788,9 @@ mod tests {
             Side::Bob,
             &PathBuf::from("nonexistent-cert.pem"),
             None,
-            None
+            None,
         )?;
-        
+
         // Add a test key to the cache
         let test_key = QKDKey {
             key_id: "test-key-id".to_string(),
@@ -740,32 +801,32 @@ mod tests {
                 qber: 0.0,
                 key_size: 5,
                 status: KeyStatus::Available,
-            }
+            },
         };
-        
+
         {
             let mut cache = client.key_cache.lock().await;
             cache.push(test_key.clone());
         }
-        
+
         // Clear the cache
         client.clear_cache().await;
-        
+
         // Verify cache is empty
         {
             let cache = client.key_cache.lock().await;
             assert_eq!(cache.len(), 0);
         }
-        
+
         Ok(())
     }
-    
+
     #[test]
     fn test_key_status_enum() {
         // Test equality
         assert_eq!(KeyStatus::Available, KeyStatus::Available);
         assert_ne!(KeyStatus::Available, KeyStatus::Pending);
-        
+
         // Test error variant
         let error_status = KeyStatus::Error("test error".to_string());
         if let KeyStatus::Error(msg) = error_status {
@@ -774,7 +835,7 @@ mod tests {
             panic!("Expected Error variant");
         }
     }
-    
+
     #[tokio::test]
     async fn test_simulated_key_generation() -> Result<(), Box<dyn Error>> {
         // Create simulated client
@@ -783,22 +844,22 @@ mod tests {
             Side::Alice,
             &PathBuf::from("nonexistent-cert.pem"),
             None,
-            None
+            None,
         )?;
-        
+
         // Generate a simulated key
         let key = client.get_key_alice(32, "test-destination", None).await?;
-        
+
         // Verify it has the right size
         assert_eq!(key.metadata.key_size, 32);
-        
+
         // Delete the key
         let result = client.delete_key(&key.key_id).await?;
         assert!(result, "Key deletion should return true");
-        
+
         Ok(())
     }
-    
+
     #[tokio::test]
     async fn test_key_consistency() -> Result<(), Box<dyn Error>> {
         // Create two clients for Alice and Bob
@@ -807,33 +868,36 @@ mod tests {
             Side::Alice,
             &PathBuf::from("nonexistent-cert.pem"),
             None,
-            None
+            None,
         )?;
-        
+
         let bob_client = ETSIClient::new(
             DeviceType::Simulated,
             Side::Bob,
             &PathBuf::from("nonexistent-cert.pem"),
             None,
-            None
+            None,
         )?;
-        
+
         // Alice generates a key
         let alice_key = alice_client.get_key_alice(32, "test-dest", None).await?;
-        
+
         // Bob retrieves the same key
         let bob_key = bob_client.get_key_bob(&alice_key.key_id).await?;
-        
+
         // Verify the keys are identical
-        assert_eq!(alice_key.key_bytes, bob_key.key_bytes, "Key bytes should be identical between Alice and Bob");
+        assert_eq!(
+            alice_key.key_bytes, bob_key.key_bytes,
+            "Key bytes should be identical between Alice and Bob"
+        );
         assert_eq!(alice_key.key_id, bob_key.key_id, "Key IDs should match");
-        
+
         Ok(())
     }
-     // Add this new method below your existing ETSIClient::new() method
-    
+    // Add this new method below your existing ETSIClient::new() method
+
     /// Create a new ETSI QKD client with separate certificate and key data
-    /// 
+    ///
     /// # Arguments
     /// * `device_type` - Type of QKD device (Toshiba, IDQ, etc.)
     /// * `side` - The side of the QKD device (Alice or Bob)
@@ -842,15 +906,15 @@ mod tests {
     /// * `root_data` - Optional root CA certificate data in PEM format
     /// * `auth_token` - Optional authentication token for API access
     pub fn with_cert_and_key(
-        device_type: DeviceType, 
-        side: Side, 
+        device_type: DeviceType,
+        side: Side,
         cert_data: Vec<u8>,
         key_data: Vec<u8>,
         root_data: Option<Vec<u8>>,
-        auth_token: Option<String>
+        auth_token: Option<String>,
     ) -> Result<ETSIClient, Box<dyn Error>> {
-        use reqwest::{Certificate, Identity, ClientBuilder};
-        
+        use reqwest::{Certificate, ClientBuilder, Identity};
+
         let base_url = match device_type {
             DeviceType::Toshiba => match side {
                 Side::Alice => "https://192.168.0.4/api/v1",
@@ -866,9 +930,9 @@ mod tests {
             },
             DeviceType::Simulated => "http://localhost:8000/api/v1",
         };
-        
+
         let mut client_builder = ClientBuilder::new();
-        
+
         // Load certificate if needed
         if matches!(device_type, DeviceType::Simulated) {
             debug!("Using simulated device, skipping certificate loading");
@@ -877,45 +941,46 @@ mod tests {
         } else {
             // Process certificate and key data
             debug!("Processing certificate and key data");
-            
+
             // The key and cert need to be combined into a PEM identity
             // First, ensure both are in PEM format
             let cert_str = String::from_utf8_lossy(&cert_data);
             let key_str = String::from_utf8_lossy(&key_data);
-            
+
             // Check if they look like PEM data
             if !cert_str.contains("-----BEGIN CERTIFICATE-----") {
                 return Err("Invalid certificate data, does not contain PEM markers".into());
             }
-            
-            if !key_str.contains("-----BEGIN PRIVATE KEY-----") && 
-               !key_str.contains("-----BEGIN RSA PRIVATE KEY-----") {
+
+            if !key_str.contains("-----BEGIN PRIVATE KEY-----")
+                && !key_str.contains("-----BEGIN RSA PRIVATE KEY-----")
+            {
                 return Err("Invalid key data, does not contain PEM markers".into());
             }
-            
+
             // Create a combined PEM file containing both cert and key
             let identity_pem = format!("{}\n{}", cert_str, key_str);
-            
+
             // Create identity from the combined PEM
             debug!("Creating identity from combined PEM data");
             let identity = Identity::from_pkcs12_der(identity_pem.as_bytes(), "MySecret")?;
             client_builder = client_builder.identity(identity);
-            
+
             // Add root CA if provided
             if let Some(data) = root_data {
                 debug!("Adding root certificate");
                 let root_cert = Certificate::from_pem(&data)?;
                 client_builder = client_builder.add_root_certificate(root_cert);
             }
-            
+
             // For real devices, we often need to disable strict verification
             client_builder = client_builder.danger_accept_invalid_certs(true);
             client_builder = client_builder.danger_accept_invalid_hostnames(true);
         }
-        
+
         // Create client with certificate
         let client = client_builder.build()?;
-        
+
         Ok(ETSIClient {
             base_url: base_url.to_string(),
             client,
@@ -924,4 +989,4 @@ mod tests {
             key_cache: std::sync::Arc::new(tokio::sync::Mutex::new(Vec::new())),
         })
     }
-}
\ No newline at end of file
+}
diff --git a/src/qkd/key_manager.rs b/src/qkd/key_manager.rs
index dc68280..342cccf 100644
--- a/src/qkd/key_manager.rs
+++ b/src/qkd/key_manager.rs
@@ -1,5 +1,5 @@
 // src/qkd/key_manager.rs
-use crate::qkd::etsi_api::{DeviceType, ETSIClient, QKDKey, KeyStatus, Side};
+use crate::qkd::etsi_api::{DeviceType, ETSIClient, KeyStatus, QKDKey, Side};
 use std::collections::HashMap;
 use std::error::Error;
 use std::path::Path;
@@ -61,14 +61,8 @@ impl SecureKeyManager {
         cert_path: &Path,
         root_cert_path: Option<&Path>,
     ) -> Result<Self, Box<dyn Error>> {
-        let client = ETSIClient::new(
-            device_type,
-            Side::Alice,
-            cert_path,
-            root_cert_path,
-            None,
-        )?;
-        
+        let client = ETSIClient::new(device_type, Side::Alice, cert_path, root_cert_path, None)?;
+
         Ok(Self::new(client))
     }
 
@@ -78,14 +72,8 @@ impl SecureKeyManager {
         cert_path: &Path,
         root_cert_path: Option<&Path>,
     ) -> Result<Self, Box<dyn Error>> {
-        let client = ETSIClient::new(
-            device_type,
-            Side::Bob,
-            cert_path,
-            root_cert_path,
-            None,
-        )?;
-        
+        let client = ETSIClient::new(device_type, Side::Bob, cert_path, root_cert_path, None)?;
+
         Ok(Self::new(client))
     }
 
@@ -105,27 +93,29 @@ impl SecureKeyManager {
     ) -> Result<QKDKey, Box<dyn Error>> {
         // Get key from QKD device
         let key = self.client.get_key_alice(key_size, dest_id, None).await?;
-        
+
         // Mark key as in use for this purpose
         {
             let mut keys_in_use = self.keys_in_use.lock().await;
             keys_in_use.insert(key.key_id.clone(), (purpose, requester_id.to_string()));
-            
+
             // Update usage statistics
             let mut stats = self.usage_stats.lock().await;
             *stats.entry(purpose).or_insert(0) += 1;
-            
+
             // Update last access time
             let mut last_access = self.last_access.lock().await;
             last_access.insert(key.key_id.clone(), SystemTime::now());
         }
-        
-        info!("Allocated quantum key {} ({} bytes) to {} for {}", 
-            key.key_id, key.metadata.key_size, requester_id, purpose);
-        
+
+        info!(
+            "Allocated quantum key {} ({} bytes) to {} for {}",
+            key.key_id, key.metadata.key_size, requester_id, purpose
+        );
+
         Ok(key)
     }
-    
+
     /// Get a specific key by ID for Bob
     ///
     /// # Arguments
@@ -144,37 +134,42 @@ impl SecureKeyManager {
             if let Some((existing_purpose, existing_requester)) = keys_in_use.get(key_id) {
                 if *existing_purpose == purpose && existing_requester == requester_id {
                     // Same purpose and requester, might be a retry - allow it
-                    debug!("Key {} already in use by the same requester, allowing retry", key_id);
+                    debug!(
+                        "Key {} already in use by the same requester, allowing retry",
+                        key_id
+                    );
                 } else {
                     // Key already in use for a different purpose or by a different requester
                     return Err(format!("Key {} has already been used", key_id).into());
                 }
             }
         }
-        
+
         // Get key from QKD device
         let key = self.client.get_key_bob(key_id).await?;
-        
+
         // Mark key as in use for this purpose
         {
             let mut keys_in_use = self.keys_in_use.lock().await;
             keys_in_use.insert(key.key_id.clone(), (purpose, requester_id.to_string()));
-            
+
             // Update usage statistics
             let mut stats = self.usage_stats.lock().await;
             *stats.entry(purpose).or_insert(0) += 1;
-            
+
             // Update last access time
             let mut last_access = self.last_access.lock().await;
             last_access.insert(key.key_id.clone(), SystemTime::now());
         }
-        
-        info!("Retrieved quantum key {} ({} bytes) for {} by {}", 
-            key.key_id, key.metadata.key_size, purpose, requester_id);
-        
+
+        info!(
+            "Retrieved quantum key {} ({} bytes) for {} by {}",
+            key.key_id, key.metadata.key_size, purpose, requester_id
+        );
+
         Ok(key)
     }
-    
+
     /// Mark a key as consumed (will prevent reuse)
     ///
     /// # Arguments
@@ -185,35 +180,35 @@ impl SecureKeyManager {
             let mut keys_in_use = self.keys_in_use.lock().await;
             keys_in_use.remove(key_id);
         }
-        
+
         // Delete from QKD device
         let result = self.client.delete_key(key_id).await?;
-        
+
         if result {
             info!("Successfully deleted consumed key: {}", key_id);
         } else {
             warn!("Failed to delete consumed key: {}", key_id);
         }
-        
+
         Ok(())
     }
-    
+
     /// Get key usage statistics
     pub async fn get_usage_statistics(&self) -> HashMap<KeyUsagePurpose, usize> {
         let stats = self.usage_stats.lock().await;
         stats.clone()
     }
-    
+
     /// Expire old keys based on max_key_age
     pub async fn expire_old_keys(&self) -> Result<usize, Box<dyn Error>> {
         let now = SystemTime::now();
         let mut expired_count = 0;
-        
+
         // Find keys to expire
         let keys_to_expire = {
             let last_access = self.last_access.lock().await;
             let mut to_expire = Vec::new();
-            
+
             for (key_id, access_time) in last_access.iter() {
                 if let Ok(elapsed) = now.duration_since(*access_time) {
                     if elapsed > self.max_key_age {
@@ -221,17 +216,17 @@ impl SecureKeyManager {
                     }
                 }
             }
-            
+
             to_expire
         };
-        
+
         // Expire the keys
         for key_id in keys_to_expire {
             if let Ok(()) = self.consume_key(&key_id).await {
                 expired_count += 1;
             }
         }
-        
+
         debug!("Expired {} old keys", expired_count);
         Ok(expired_count)
     }
@@ -241,7 +236,7 @@ impl SecureKeyManager {
 mod tests {
     use super::*;
     use std::path::PathBuf;
-    
+
     #[tokio::test]
     async fn test_key_allocation() -> Result<(), Box<dyn Error>> {
         // Create simulated client
@@ -252,25 +247,27 @@ mod tests {
             None,
             None,
         )?;
-        
+
         let manager = SecureKeyManager::new(client);
-        
+
         // Get a key
-        let key = manager.get_key(32, "test-dest", KeyUsagePurpose::Encryption, "test").await?;
-        
+        let key = manager
+            .get_key(32, "test-dest", KeyUsagePurpose::Encryption, "test")
+            .await?;
+
         // Verify it has the right size
         assert_eq!(key.metadata.key_size, 32);
-        
+
         // Get usage stats
         let stats = manager.get_usage_statistics().await;
         assert_eq!(stats.get(&KeyUsagePurpose::Encryption), Some(&1));
-        
+
         // Mark key as consumed
         manager.consume_key(&key.key_id).await?;
-        
+
         Ok(())
     }
-    
+
     #[tokio::test]
     async fn test_key_reuse_prevention() -> Result<(), Box<dyn Error>> {
         // Create simulated client
@@ -281,7 +278,7 @@ mod tests {
             None,
             None,
         )?;
-        
+
         let bob_client = ETSIClient::new(
             DeviceType::Simulated,
             Side::Bob,
@@ -289,23 +286,29 @@ mod tests {
             None,
             None,
         )?;
-        
+
         let alice_manager = SecureKeyManager::new(alice_client);
         let bob_manager = SecureKeyManager::new(bob_client);
-        
+
         // Alice gets a key
-        let key = alice_manager.get_key(32, "test-dest", KeyUsagePurpose::Encryption, "test1").await?;
-        
+        let key = alice_manager
+            .get_key(32, "test-dest", KeyUsagePurpose::Encryption, "test1")
+            .await?;
+
         // Bob retrieves the same key
-        let bob_key = bob_manager.get_key_by_id(&key.key_id, KeyUsagePurpose::Encryption, "test2").await?;
-        
+        let bob_key = bob_manager
+            .get_key_by_id(&key.key_id, KeyUsagePurpose::Encryption, "test2")
+            .await?;
+
         // Verify it's the same key
         assert_eq!(key.key_bytes, bob_key.key_bytes);
-        
+
         // Try to reuse the key for a different purpose (should fail)
-        let reuse_result = bob_manager.get_key_by_id(&key.key_id, KeyUsagePurpose::Authentication, "test3").await;
+        let reuse_result = bob_manager
+            .get_key_by_id(&key.key_id, KeyUsagePurpose::Authentication, "test3")
+            .await;
         assert!(reuse_result.is_err(), "Key reuse should be prevented");
-        
+
         Ok(())
     }
-}
\ No newline at end of file
+}
diff --git a/src/reporter/qkd_client.rs b/src/reporter/qkd_client.rs
index e443bfc..ac2c183 100644
--- a/src/reporter/qkd_client.rs
+++ b/src/reporter/qkd_client.rs
@@ -1,13 +1,8 @@
-// src/reporter/qkd_client.rs
 use crate::quantum_auth::QuantumAuthenticator;
 use reqwest::{Certificate, Client, Identity};
 use serde::{Deserialize, Serialize};
-use std::error::Error;
-use std::fs::File;
-use std::io::Read;
-use std::path::Path;
-use std::time::Duration;
-use tracing::{debug, info};
+use std::{error::Error, fs, path::Path, time::Duration};
+use tracing::{debug, info, warn};
 
 #[derive(Debug, Serialize)]
 struct KeyRequest {
@@ -18,11 +13,11 @@ struct KeyRequest {
 
 #[derive(Debug, Deserialize)]
 struct KeyResponse {
-    keys: Vec<Key>,
+    keys: Vec<QKDKey>,
 }
 
 #[derive(Debug, Deserialize)]
-struct Key {
+struct QKDKey {
     #[serde(rename = "key_ID")]
     key_id: String,
     key: String,
@@ -30,93 +25,105 @@ struct Key {
 
 pub struct QKDClient {
     client: Client,
-    auth: QuantumAuthenticator,
+    authenticator: QuantumAuthenticator,
     base_url: String,
 }
 
-fn read_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
-    debug!("📂 Reading file: {}", path.display());
-    let mut file = File::open(path)?;
-    let mut contents = Vec::new();
-    file.read_to_end(&mut contents)?;
-    debug!("✅ Successfully read {} bytes", contents.len());
-    Ok(contents)
-}
-
 impl QKDClient {
     pub fn new() -> Result<Self, Box<dyn Error>> {
-        // Load certificates
-        let p12_path =
+        // Certificate paths
+        let pkcs12_path =
             Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
-        let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
-
-        debug!("Loading PKCS#12 and CA certificates...");
-        let pkcs12_bytes = read_file(p12_path)?;
-        let ca_contents = read_file(ca_path)?;
+        let ca_cert_path =
+            Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");
 
-        let ca_cert = Certificate::from_pem(&ca_contents)?;
+        // Load certificates securely
+        let identity = Self::load_identity(pkcs12_path, "MySecret")?;
+        let ca_cert = Self::load_ca_certificate(ca_cert_path)?;
 
-        // Build client with certificates
+        // Build secure HTTP client
         let client = Client::builder()
             .add_root_certificate(ca_cert)
-            .identity(Identity::from_pkcs12_der(&pkcs12_bytes, "MySecret")?)
-            .danger_accept_invalid_certs(true)
-            .danger_accept_invalid_hostnames(true)
+            .identity(identity)
+            .danger_accept_invalid_certs(true) // 🚨 For testing only; disable in production
+            .danger_accept_invalid_hostnames(true) // 🚨 For testing only; disable in production
             .timeout(Duration::from_secs(5))
             .build()?;
 
+        debug!("✅ HTTP client configured successfully");
+
         Ok(Self {
             client,
-            auth: QuantumAuthenticator::new()?,
-            base_url: "https://192.168.0.4".to_string(),
+            authenticator: QuantumAuthenticator::new()?,
+            base_url: "https://192.168.0.4".into(),
         })
     }
 
+    /// Retrieve a quantum-generated encryption key from the QKD server
     pub async fn get_key(&self) -> Result<Vec<u8>, Box<dyn Error>> {
         let url = format!("{}/api/v1/keys/bobsae/enc_keys", self.base_url);
-        debug!("Retrieving key from {}", url);
+        debug!("Requesting quantum key from URL: {}", url);
 
-        // Generate quantum auth proof
-        let auth_proof = self.auth.authenticate()?;
+        // Generate quantum authentication proof
+        let auth_proof = self.authenticator.authenticate()?;
 
-        // Build request
-        let request = KeyRequest {
-            sae_id: "bobsae".to_string(),
+        // Prepare key request payload
+        let key_request = KeyRequest {
+            sae_id: "bobsae".into(),
             key_size: 256,
             number_of_keys: 1,
         };
 
-        // Send request
-        debug!("Sending request: {:?}", request);
+        // Send POST request to QKD server
         let response = self
             .client
             .post(&url)
-            .json(&request)
-            .header("X-Quantum-Auth", base64::encode(&auth_proof))
+            .json(&key_request)
+            .header("X-Quantum-Auth", base64::encode(auth_proof))
             .send()
             .await?;
 
+        debug!("Received response status: {}", response.status());
+
         let status = response.status();
-        debug!("Response status: {}", status);
+        let response_text = response.text().await?;
 
         if !status.is_success() {
-            return Err(format!("Request failed with status: {}", status).into());
+            warn!("QKD server returned error: {}", response_text);
+            return Err(format!("QKD request failed ({}): {}", status, response_text).into());
         }
 
-        // Parse response
-        let response_text = response.text().await?;
+        // Deserialize response
         let key_response: KeyResponse = serde_json::from_str(&response_text)?;
 
-        if key_response.keys.is_empty() {
-            return Err("No keys returned from server".into());
-        }
+        // Ensure at least one key is present
+        let qkd_key = key_response
+            .keys
+            .get(0)
+            .ok_or("No keys returned by QKD server")?;
 
         // Decode key from base64
-        let key = base64::decode(&key_response.keys[0].key)?;
-        let key_id = &key_response.keys[0].key_id;
+        let key_bytes = base64::decode(&qkd_key.key)?;
+        info!("🔑 Successfully retrieved quantum key (ID: {})", qkd_key.key_id);
 
-        info!("Successfully retrieved key with ID: {}", key_id);
+        Ok(key_bytes)
+    }
+
+    /// Load identity certificate from PKCS#12 file
+    fn load_identity(path: &Path, password: &str) -> Result<Identity, Box<dyn Error>> {
+        debug!("Loading identity certificate from {}", path.display());
+        let pkcs12_data = fs::read(path)?;
+        let identity = Identity::from_pkcs12_der(&pkcs12_data, password)?;
+        debug!("✅ Identity certificate loaded");
+        Ok(identity)
+    }
 
-        Ok(key)
+    /// Load CA certificate from PEM file
+    fn load_ca_certificate(path: &Path) -> Result<Certificate, Box<dyn Error>> {
+        debug!("Loading CA certificate from {}", path.display());
+        let ca_cert_data = fs::read(path)?;
+        let ca_cert = Certificate::from_pem(&ca_cert_data)?;
+        debug!("✅ CA certificate loaded");
+        Ok(ca_cert)
     }
 }
diff --git a/src/vrf/integrated_vrf.rs b/src/vrf/integrated_vrf.rs
index dbd980a..c603cde 100644
--- a/src/vrf/integrated_vrf.rs
+++ b/src/vrf/integrated_vrf.rs
@@ -11,8 +11,8 @@ use tracing::{debug, info, warn};
 pub struct VRFResponse {
     pub output: Vec<u8>,
     pub vrf_proof: Vec<u8>,
-    pub zk_proof: Value,       // The real ZK proof (as JSON)
-    pub public_inputs: Value,  // The public inputs from the circuit
+    pub zk_proof: Value,      // The real ZK proof (as JSON)
+    pub public_inputs: Value, // The public inputs from the circuit
 }
 
 /// Integrated VRF that now generates a real ZK proof using our circuit manager.
@@ -26,7 +26,10 @@ impl IntegratedVRF {
     pub fn new(hybrid_auth: HybridAuth) -> Result<Self, Box<dyn Error>> {
         let vrf = QuantumVRF::new(hybrid_auth);
         let circuit_manager = CircuitManager::new()?;
-        Ok(Self { vrf, circuit_manager })
+        Ok(Self {
+            vrf,
+            circuit_manager,
+        })
     }
 
     /// Generate VRF output and a zero‐knowledge proof.
@@ -61,8 +64,9 @@ impl IntegratedVRF {
         });
 
         // Generate a real ZK proof using the circuit manager.
-        let (zk_proof, public_inputs) =
-            self.circuit_manager.generate_proof("vrf_seed_proof", circuit_input)?;
+        let (zk_proof, public_inputs) = self
+            .circuit_manager
+            .generate_proof("vrf_seed_proof", circuit_input)?;
 
         info!("VRF generation completed in {:?}", start.elapsed());
 
@@ -85,7 +89,8 @@ impl IntegratedVRF {
         let start = Instant::now();
 
         let vrf_valid =
-            self.vrf.verify(input, &response.output, &response.vrf_proof, quantum_key)?;
+            self.vrf
+                .verify(input, &response.output, &response.vrf_proof, quantum_key)?;
         if !vrf_valid {
             warn!("VRF verification failed");
             return Ok(false);
diff --git a/src/zk/circuit_manager.rs b/src/zk/circuit_manager.rs
index bdb2992..890bbdf 100644
--- a/src/zk/circuit_manager.rs
+++ b/src/zk/circuit_manager.rs
@@ -29,12 +29,24 @@ impl CircuitManager {
         info!("Generating proof for circuit: {}", circuit_name);
 
         // Set up file paths based on your folder structure.
-        let wasm_path = self.circuits_dir.join(format!("{}_js/{}.wasm", circuit_name, circuit_name));
-        let zkey_path = self.circuits_dir.join(format!("{}_final.zkey", circuit_name));
-        let input_path = self.circuits_dir.join(format!("{}_input.json", circuit_name));
-        let witness_path = self.circuits_dir.join(format!("{}_witness.wtns", circuit_name));
-        let proof_path = self.circuits_dir.join(format!("{}_proof.json", circuit_name));
-        let public_path = self.circuits_dir.join(format!("{}_public.json", circuit_name));
+        let wasm_path = self
+            .circuits_dir
+            .join(format!("{}_js/{}.wasm", circuit_name, circuit_name));
+        let zkey_path = self
+            .circuits_dir
+            .join(format!("{}_final.zkey", circuit_name));
+        let input_path = self
+            .circuits_dir
+            .join(format!("{}_input.json", circuit_name));
+        let witness_path = self
+            .circuits_dir
+            .join(format!("{}_witness.wtns", circuit_name));
+        let proof_path = self
+            .circuits_dir
+            .join(format!("{}_proof.json", circuit_name));
+        let public_path = self
+            .circuits_dir
+            .join(format!("{}_public.json", circuit_name));
 
         // Write the JSON input to file.
         fs::write(&input_path, serde_json::to_string_pretty(&input)?)?;
@@ -44,7 +56,8 @@ impl CircuitManager {
         info!("Generating witness...");
         let status = Command::new("snarkjs")
             .args(&[
-                "wtns", "calculate",
+                "wtns",
+                "calculate",
                 wasm_path.to_str().unwrap(),
                 input_path.to_str().unwrap(),
                 witness_path.to_str().unwrap(),
@@ -60,7 +73,8 @@ impl CircuitManager {
         info!("Generating proof...");
         let status = Command::new("snarkjs")
             .args(&[
-                "groth16", "prove",
+                "groth16",
+                "prove",
                 zkey_path.to_str().unwrap(),
                 witness_path.to_str().unwrap(),
                 proof_path.to_str().unwrap(),
diff --git a/src/zk/mod.rs b/src/zk/mod.rs
index 4aecdc5..bcc7c29 100644
--- a/src/zk/mod.rs
+++ b/src/zk/mod.rs
@@ -2,6 +2,6 @@ pub mod circuit;
 pub mod proof;
 pub mod vrf;
 pub use self::proof::KeyProof;
+pub mod circuit_manager;
 pub mod multi_source_generator;
 pub mod multi_source_proof;
-pub mod circuit_manager;
diff --git a/src/zk/multi_source_proof.rs b/src/zk/multi_source_proof.rs
index 507600a..737e26f 100644
--- a/src/zk/multi_source_proof.rs
+++ b/src/zk/multi_source_proof.rs
@@ -17,7 +17,7 @@ pub struct MultiSourceKeyProof {
 }
 
 impl MultiSourceKeyProof {
-    // Generate a new proof from multiple quantum key sources
+    // ✅ Fixed visibility and parameter names
     pub async fn new(
         sources: &[ReporterEntry],
         threshold: usize,
@@ -28,7 +28,7 @@ impl MultiSourceKeyProof {
             sources.len(),
             threshold
         );
-        // Get current directory and set paths
+
         let current_dir = std::env::current_dir()?;
         let circuits_dir = current_dir.join("circuits");
 
@@ -51,6 +51,7 @@ impl MultiSourceKeyProof {
         let input = Self::prepare_input_file(sources, threshold, nonce)?;
         fs::write(&input_path, input.to_string())?;
         debug!("Created multi-source input file at {:?}", input_path);
+
         // Generate witness
         info!("Generating witness for multiple sources...");
         let status = Command::new("snarkjs")
@@ -66,6 +67,7 @@ impl MultiSourceKeyProof {
             return Err("Failed to generate witness for multiple sources".into());
         }
         info!("✅ Generated multi-source witness successfully");
+
         // Generate proof
         info!("Generating multi-source proof...");
         let status = Command::new("snarkjs")
@@ -82,6 +84,7 @@ impl MultiSourceKeyProof {
             return Err("Failed to generate multi-source proof".into());
         }
         info!("✅ Generated multi-source proof successfully");
+
         // Read proof and verification files
         let proof: Value = serde_json::from_str(&fs::read_to_string(&proof_path)?)?;
         let verification_key: Value = serde_json::from_str(&fs::read_to_string(&vkey_path)?)?;
@@ -93,66 +96,47 @@ impl MultiSourceKeyProof {
             .ok_or("Invalid public inputs format")?;
 
         // Check if we have enough elements
-        if inputs.len() < 2 {
-            // If we don't have enough elements, use default values
-            info!("Public inputs don't contain commitment and VRF seed, using defaults");
-            let combined_commitment = "default-commitment".to_string();
-            let vrf_seed = "default-seed".to_string();
-
-            info!("Using default commitment: {}", combined_commitment);
-            info!("Using default VRF seed: {}", vrf_seed);
-
-            Ok(Self {
-                proof,
-                verification_key,
-                public_inputs,
-                combined_commitment,
-                vrf_seed,
-            })
+        let (combined_commitment, vrf_seed) = if inputs.len() >= 2 {
+            (
+                inputs[inputs.len() - 2]
+                    .as_str()
+                    .unwrap_or("unknown-commitment")
+                    .to_string(),
+                inputs[inputs.len() - 1]
+                    .as_str()
+                    .unwrap_or("unknown-seed")
+                    .to_string(),
+            )
         } else {
-            // The last two elements should be combinedCommitment and vrfSeed
-            let combined_commitment = inputs
-                .get(inputs.len() - 2)
-                .and_then(|v| v.as_str())
-                .unwrap_or("unknown-commitment")
-                .to_string();
-
-            let vrf_seed = inputs
-                .get(inputs.len() - 1)
-                .and_then(|v| v.as_str())
-                .unwrap_or("unknown-seed")
-                .to_string();
-
-            info!("Generated commitment: {}", combined_commitment);
-            info!("Generated VRF seed: {}", vrf_seed);
-
-            Ok(Self {
-                proof,
-                verification_key,
-                public_inputs,
-                combined_commitment,
-                vrf_seed,
-            })
-        }
+            info!("Public inputs don't contain commitment and VRF seed, using defaults");
+            ("default-commitment".to_string(), "default-seed".to_string())
+        };
+
+        info!("Generated commitment: {}", combined_commitment);
+        info!("Generated VRF seed: {}", vrf_seed);
+
+        Ok(Self {
+            proof,
+            verification_key,
+            public_inputs,
+            combined_commitment,
+            vrf_seed,
+        })
     }
 
-    // Verify this multi-source proof
     pub fn verify(&self) -> Result<bool, Box<dyn Error>> {
         info!("Verifying multi-source proof...");
 
-        // Get current directory and set paths
         let current_dir = std::env::current_dir()?;
         let circuits_dir = current_dir.join("circuits");
         let proof_verify_path = circuits_dir.join("multi_source_proof_to_verify.json");
         let vkey_path = circuits_dir.join("multi_source_verification_key.json");
         let public_path = circuits_dir.join("multi_source_public.json");
 
-        // Write files for verification
         fs::write(&proof_verify_path, serde_json::to_string(&self.proof)?)?;
         fs::write(&vkey_path, serde_json::to_string(&self.verification_key)?)?;
         fs::write(&public_path, serde_json::to_string(&self.public_inputs)?)?;
 
-        // Verify using snarkjs
         let output = Command::new("snarkjs")
             .args(&[
                 "groth16",
@@ -174,7 +158,6 @@ impl MultiSourceKeyProof {
         Ok(is_valid)
     }
 
-    // Export the proof and public inputs for third-party verification
     pub fn export_for_verification(&self, path: &Path) -> Result<(), Box<dyn Error>> {
         let export_data = json!({
             "proof": self.proof,
@@ -190,17 +173,14 @@ impl MultiSourceKeyProof {
         Ok(())
     }
 
-    // Get the combined commitment (for smart contracts, etc.)
     pub fn get_commitment(&self) -> &str {
         &self.combined_commitment
     }
 
-    // Get the VRF seed
     pub fn get_vrf_seed(&self) -> &str {
         &self.vrf_seed
     }
 
-    // Helper: Check if file exists
     fn check_file_exists(path: PathBuf) -> Result<PathBuf, Box<dyn Error>> {
         if !path.exists() {
             return Err(format!("Required file not found at {:?}", path).into());
@@ -208,23 +188,21 @@ impl MultiSourceKeyProof {
         Ok(path)
     }
 
-    // Helper: Generate JSON input for the circuit
     fn prepare_input_file(
         sources: &[ReporterEntry],
         threshold: usize,
         nonce: u64,
     ) -> Result<Value, Box<dyn Error>> {
-        // Extract just the needed fields for the circuit
-        let source_count = sources.len() as u64;
+        let source_count = sources.len();
 
-        // Create validSources array with correct size (N from the circuit template)
         let mut valid_sources = vec![0; 8];
         for i in 0..std::cmp::min(sources.len(), 8) {
-            valid_sources[i] = 1; // Mark sources as valid up to our count
+            valid_sources[i] = 1;
         }
 
-        // Create simplified input that matches circuit expectations
         let input_json = json!({
+            "threshold": threshold,
+            "nonce": nonce,
             "sourceCount": source_count,
             "validSources": valid_sources
         });
diff --git a/zk_implementation_analysis.txt b/zk_implementation_analysis.txt
deleted file mode 100644
index 32d9e04..0000000
--- a/zk_implementation_analysis.txt
+++ /dev/null
@@ -1,761 +0,0 @@
-# ZK Implementation Analysis
-Generated on Thu Mar  6 05:34:19 AM EST 2025
-
-### VRF Implementation Files
-
-
-## File: src/vrf/integrated_vrf.rs
-
-```
-// src/vrf/integrated_vrf.rs
-use super::core::QuantumVRF;
-use crate::quantum_auth::hybrid::HybridAuth;
-use crate::zk::circuit_manager::CircuitManager;
-use serde_json::{json, Value};
-use std::error::Error;
-use std::time::Instant;
-use tracing::{debug, info, warn};
-
-#[derive(Debug, Clone)]
-pub struct VRFResponse {
-    pub output: Vec<u8>,
-    pub vrf_proof: Vec<u8>,
-    pub zk_proof: String, // Base64-encoded ZK proof
-    pub public_inputs: Value,
-}
-
-/// Integrated VRF implementation that combines quantum VRF with zero-knowledge proofs
-pub struct IntegratedVRF {
-    vrf: QuantumVRF,
-    zk_manager: CircuitManager,
-}
-
-impl IntegratedVRF {
-    /// Create a new integrated VRF with zero-knowledge proof capabilities
-    pub fn new(hybrid_auth: HybridAuth) -> Self {
-        // Create VRF component
-        let vrf = QuantumVRF::new(hybrid_auth);
-        
-        // Create ZK circuit manager (using default or custom error handling)
-        let zk_manager = match CircuitManager::new() {
-            Ok(manager) => manager,
-            Err(e) => {
-                warn!("Failed to initialize ZK circuit manager: {}", e);
-                // Fallback to using the current directory
-                let current_dir = std::env::current_dir().unwrap_or_default();
-                CircuitManager::with_circuits_dir(current_dir.join("circuits"))
-            }
-        };
-        
-        Self { vrf, zk_manager }
-    }
-
-    /// Generate VRF output with zero-knowledge proof of quantum key authenticity
-    pub fn generate_with_proof(
-        &self,
-        input: &[u8],
-        quantum_key: &[u8],
-    ) -> Result<VRFResponse, Box<dyn Error>> {
-        debug!("Generating VRF output");
-        let start = Instant::now();
-
-        // Generate VRF output and proof using quantum key
-        let (output, vrf_proof) = self.vrf.generate(input, quantum_key)?;
-        debug!("Generated VRF output in {:?}", start.elapsed());
-
-        // Generate ZK proof for VRF seed validity
-        let (zk_proof, public_inputs) = self.generate_zk_proof(input, quantum_key, &vrf_proof)?;
-
-        info!("VRF generation completed in {:?}", start.elapsed());
-        Ok(VRFResponse {
-            output,
-            vrf_proof,
-            zk_proof,
-            public_inputs,
-        })
-    }
-
-    /// Generate a zero-knowledge proof for the VRF seed
-    fn generate_zk_proof(
-        &self,
-        input: &[u8],
-        quantum_key: &[u8],
-        vrf_proof: &[u8],
-    ) -> Result<(String, Value), Box<dyn Error>> {
-        let start = Instant::now();
-
-        // Try to generate a real ZK proof
-        match self.try_generate_zk_proof(input, quantum_key, vrf_proof) {
-            Ok((proof, inputs)) => {
-                info!("Generated ZK proof in {:?}", start.elapsed());
-                Ok((serde_json::to_string(&proof)?, inputs))
-            }
-            Err(e) => {
-                warn!("ZK proof generation failed: {}, using placeholder", e);
-                
-                // Return a placeholder when generation fails
-                Ok((String::new(), json!({})))
-            }
-        }
-    }
-
-    /// Attempt to generate a real ZK proof
-    fn try_generate_zk_proof(
-        &self,
-        input: &[u8],
-        quantum_key: &[u8],
-        _vrf_proof: &[u8],
-    ) -> Result<(Value, Value), Box<dyn Error>> {
-        // Prepare circuit inputs
-        // We use hex encoding for byte arrays to make them JSON-friendly
-        let circuit_input = json!({
-            "quantumKey": format!("0x{}", hex::encode(quantum_key)),
-            "inputData": format!("0x{}", hex::encode(input)),
-            // For simplicity, we're using a placeholder vrfSeed
-            // In a real implementation, this should be derived from the VRF calculation
-            "vrfSeed": format!("0x{}", hex::encode(sha256(&[quantum_key, input].concat())))
-        });
-
-        // Generate proof using the circuit manager
-        self.zk_manager.generate_proof("vrf_seed_proof", circuit_input)
-    }
-
-    /// Verify VRF output and its zero-knowledge proof
-    pub fn verify_with_proof(
-        &self,
-        input: &[u8],
-        response: &VRFResponse,
-        quantum_key: &[u8],
-    ) -> Result<bool, Box<dyn Error>> {
-        debug!("Verifying VRF output");
-        let start = Instant::now();
-
-        // First, verify the VRF output using the quantum key
-        let vrf_valid =
-            self.vrf
-                .verify(input, &response.output, &response.vrf_proof, quantum_key)?;
-
-        if !vrf_valid {
-            warn!("VRF verification failed");
-            return Ok(false);
-        }
-
-        debug!("VRF output verified successfully");
-
-        // Verify ZK proof if available
-        let zk_valid = if !response.zk_proof.is_empty() {
-            match self.verify_zk_proof(input, quantum_key, response) {
-                Ok(valid) => valid,
-                Err(e) => {
-                    warn!("ZK proof verification error: {}", e);
-                    // For backward compatibility, we consider it valid if verification fails
-                    true
-                }
-            }
-        } else {
-            // For backward compatibility with responses that don't include ZK proofs
-            debug!("No ZK proof provided");
-            true
-        };
-
-        info!(
-            "VRF verification completed in {:?}: {}",
-            start.elapsed(),
-            vrf_valid && zk_valid
-        );
-
-        Ok(vrf_valid && zk_valid)
-    }
-
-    /// Verify the zero-knowledge proof
-    fn verify_zk_proof(
-        &self,
-        input: &[u8],
-        quantum_key: &[u8],
-        response: &VRFResponse,
-    ) -> Result<bool, Box<dyn Error>> {
-        // Parse the ZK proof
-        let proof: Value = serde_json::from_str(&response.zk_proof)?;
-        
-        // Verify using the circuit manager
-        self.zk_manager.verify_proof("vrf_seed_proof", &proof, &response.public_inputs)
-    }
-}
-
-// Helper function to compute SHA-256 hash
-fn sha256(data: &[u8]) -> [u8; 32] {
-    use sha3::Digest;
-    use sha3::Sha3_256; // Use Sha3_256 instead of Sha256
-    let mut hasher = Sha3_256::new();
-    hasher.update(data);
-    let result = hasher.finalize();
-    let mut output = [0u8; 32];
-    output.copy_from_slice(&result);
-    output
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_integrated_vrf() -> Result<(), Box<dyn Error>> {
-        // Create hybrid auth for testing
-        let hybrid_auth = HybridAuth::new()?;
-        
-        // Create integrated VRF
-        let vrf = IntegratedVRF::new(hybrid_auth);
-        
-        // Test values
-        let input = b"Test integrated VRF input";
-        let quantum_key = b"Quantum key for integrated VRF testing";
-        
-        // Generate output and proofs
-        let response = vrf.generate_with_proof(input, quantum_key)?;
-        
-        // Verify the output and proofs
-        let valid = vrf.verify_with_proof(input, &response, quantum_key)?;
-        assert!(valid, "Integrated VRF verification should succeed");
-        
-        Ok(())
-    }
-    
-    #[test]
-    fn test_sha256() {
-        let data = b"test data";
-        let hash = sha256(data);
-        assert_eq!(hash.len(), 32);
-    }
-}```
-
-
-## File: src/vrf/core.rs
-
-```
-use crate::quantum_auth::hybrid::HybridAuth;
-use sha3::{Digest, Sha3_512};
-use std::error::Error;
-use tracing::{debug, info};
-
-/// Verifiable Random Function implementation using quantum authentication
-///
-/// This VRF creates unpredictable but verifiable randomness from quantum keys
-/// by combining the input with a quantum key and using hybrid authentication
-/// as the source of verifiability.
-pub struct QuantumVRF {
-    signer: HybridAuth,
-}
-
-impl QuantumVRF {
-    /// Create a new VRF using the provided hybrid auth system
-    pub fn new(signer: HybridAuth) -> Self {
-        Self { signer }
-    }
-
-    /// Generate a random value and proof based on quantum key input
-    ///
-    /// # Arguments
-    /// * `input` - Public input data (e.g., round number, context)
-    /// * `quantum_key` - Quantum key from QKD (remains secret)
-    ///
-    /// # Returns
-    /// Tuple of (random_output, proof)
-    pub fn generate(
-        &self,
-        input: &[u8],
-        quantum_key: &[u8],
-    ) -> Result<(Vec<u8>, Vec<u8>), Box<dyn Error>> {
-        debug!(
-            "Generating VRF output from quantum key, input length: {}",
-            input.len()
-        );
-
-        // Combine input with quantum key to create seed
-        let mut hasher = Sha3_512::new();
-        hasher.update(input);
-        hasher.update(quantum_key);
-        let seed = hasher.finalize().to_vec();
-        debug!("Generated VRF seed from quantum key and input");
-
-        // Use the seed to generate a signature (serves as the proof)
-        let signature = self.signer.sign(&seed)?;
-
-        // Serialize the signature for use as proof
-        let start = std::time::Instant::now();
-        let signature_bytes = HybridAuth::serialize_signature(&signature)?
-            .as_bytes()
-            .to_vec();
-        debug!("Serialized signature in {:?}", start.elapsed());
-
-        // Hash the signature to get the random output
-        let mut output_hasher = Sha3_512::new();
-        output_hasher.update(&signature_bytes);
-        let random_output = output_hasher.finalize().to_vec();
-
-        info!(
-            "VRF output generated successfully: {} bytes, proof: {} bytes",
-            random_output.len(),
-            signature_bytes.len()
-        );
-        Ok((random_output, signature_bytes))
-    }
-
-    /// Verify a VRF output with its proof
-    ///
-    /// # Arguments
-    /// * `input` - The same public input used for generation
-    /// * `output` - The random output to verify
-    /// * `proof` - The proof of correct generation
-    /// * `quantum_key` - The quantum key used for generation
-    ///
-    /// # Returns
-    /// `true` if the output was correctly derived from the input and quantum key
-    pub fn verify(
-        &self,
-        input: &[u8],
-        output: &[u8],
-        proof: &[u8],
-        quantum_key: &[u8],
-    ) -> Result<bool, Box<dyn Error>> {
-        debug!("Verifying VRF output, input length: {}", input.len());
-
-        // Recreate the seed
-        let mut hasher = Sha3_512::new();
-        hasher.update(input);
-        hasher.update(quantum_key);
-        let seed = hasher.finalize().to_vec();
-
-        // Deserialize and verify the signature (proof)
-        let start = std::time::Instant::now();
-        let signature = HybridAuth::deserialize_signature(&String::from_utf8(proof.to_vec())?)?;
-
-        if !self.signer.verify(&seed, &signature)? {
-            debug!("VRF verification failed - invalid signature");
-            return Ok(false);
-        }
-        debug!("VRF signature verified in {:?}", start.elapsed());
-
-        // Verify the output by hashing the signature
-        let mut output_hasher = Sha3_512::new();
-        output_hasher.update(proof);
-        let expected_output = output_hasher.finalize().to_vec();
-
-        let valid = &expected_output[..] == output;
-        info!(
-            "VRF verification result: {}",
-            if valid { "valid" } else { "invalid" }
-        );
-        Ok(valid)
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_vrf_generation_and_verification() -> Result<(), Box<dyn Error>> {
-        // Initialize auth system for testing
-        let auth = HybridAuth::new()?;
-        let vrf = QuantumVRF::new(auth);
-
-        // Test values
-        let input = b"Test VRF input";
-        let quantum_key = b"Quantum key for testing";
-
-        // Generate output and proof
-        let (output, proof) = vrf.generate(input, quantum_key)?;
-
-        // Verify the output
-        let valid = vrf.verify(input, &output, &proof, quantum_key)?;
-        assert!(valid, "VRF verification should succeed");
-
-        // Test with modified input (should fail)
-        let modified_input = b"Modified input";
-        let valid = vrf.verify(modified_input, &output, &proof, quantum_key)?;
-        assert!(!valid, "VRF verification should fail with modified input");
-
-        Ok(())
-    }
-}
-```
-### ZK Proof Files
-
-
-## File: src/zk/mod.rs
-
-```
-pub mod circuit;
-pub mod proof;
-pub mod vrf;
-pub use self::proof::KeyProof;
-pub mod multi_source_generator;
-pub mod multi_source_proof;
-pub mod circuit_manager; ```
-
-
-## File: src/zk/multi_source_generator.rs
-
-```
-// src/zk/multi_source_generator.rs
-use std::error::Error;
-use std::sync::Arc;
-use tracing::info;
-
-use crate::byzantine::buffer::{ReporterEntry, SharedBuffer};
-use crate::byzantine::consensus::{ByzantineConsensus, ConsensusResult};
-use crate::zk::multi_source_proof::MultiSourceKeyProof;
-use crate::zk::vrf::VerifiableRandomFunction;
-
-/// Generator for multi-source proofs from Byzantine consensus
-pub struct MultiSourceProofGenerator {
-    buffer: Arc<SharedBuffer>,
-    threshold: usize,
-}
-
-/// Result of the multi-source proof generation
-pub struct MultiSourceProofResult {
-    pub proof: MultiSourceKeyProof,
-    pub vrf: VerifiableRandomFunction,
-    pub source_count: usize,
-    pub consensus_result: ConsensusResult,
-}
-
-impl MultiSourceProofGenerator {
-    /// Create a new multi-source proof generator
-    pub fn new(buffer: Arc<SharedBuffer>, threshold: usize) -> Self {
-        Self { buffer, threshold }
-    }
-
-    /// Generate a proof from the current state of the buffer
-    pub async fn generate_proof(&self) -> Result<MultiSourceProofResult, Box<dyn Error>> {
-        // Get all reports from the buffer
-        let reports = self.buffer.get_all_reports();
-        if reports.is_empty() {
-            return Err("No reports available for proof generation".into());
-        }
-
-        info!(
-            "Generating multi-source proof from {} reports",
-            reports.len()
-        );
-
-        // Create multi-source proof
-        let nonce = std::time::SystemTime::now()
-            .duration_since(std::time::UNIX_EPOCH)?
-            .as_secs();
-
-        let proof = MultiSourceKeyProof::new(&reports, self.threshold, nonce).await?;
-
-        // Create a VRF from the proof commitment and seed
-        let vrf = VerifiableRandomFunction::from_multi_source_proof(
-            proof.get_commitment(),
-            proof.get_vrf_seed(),
-        )?;
-
-        // Create a placeholder consensus result (in a real implementation,
-        // this would be the actual result from running Byzantine consensus)
-        let consensus_result = ConsensusResult {
-            success: true,
-            value: Some(proof.get_commitment().as_bytes().to_vec()),
-            reporter_ids: reports.iter().map(|r| r.reporter_id.clone()).collect(),
-            round_duration: std::time::Duration::from_secs(0),
-            round_number: 0,
-            total_messages: reports.len(),
-        };
-
-        Ok(MultiSourceProofResult {
-            proof,
-            vrf,
-            source_count: reports.len(),
-            consensus_result,
-        })
-    }
-
-    /// Generate proof after running Byzantine consensus
-    pub async fn generate_proof_with_consensus(
-        &self,
-        consensus: &ByzantineConsensus,
-    ) -> Result<MultiSourceProofResult, Box<dyn Error>> {
-        info!("Running Byzantine consensus before generating proof");
-
-        let consensus_result = consensus.run_consensus_round()?;
-
-        if !consensus_result.success {
-            return Err("Byzantine consensus failed, cannot generate proof".into());
-        }
-
-        let proof_result = self.generate_proof().await?;
-
-        Ok(MultiSourceProofResult {
-            proof: proof_result.proof,
-            vrf: proof_result.vrf,
-            consensus_result: consensus_result.clone(),
-            source_count: consensus_result.total_messages,
-        })
-    }
-
-    /// Add a report to the buffer
-    pub fn add_report(&self, report: ReporterEntry) {
-        self.buffer.add_report(report);
-    }
-}
-```
-
-
-## File: src/zk/multi_source_proof.rs
-
-```
-// src/zk/multi_source_proof.rs
-use crate::byzantine::buffer::ReporterEntry;
-use crate::zk::circuit_manager::CircuitManager;
-use serde_json::{json, Value};
-use std::error::Error;
-use std::fs;
-use std::path::{Path, PathBuf};
-use tracing::{debug, info};
-
-// Represents a proof for multiple quantum sources
-pub struct MultiSourceKeyProof {
-    proof: Value,
-    verification_key: Value,
-    public_inputs: Value,
-    combined_commitment: String,
-    vrf_seed: String,
-}
-
-impl MultiSourceKeyProof {
-    // Generate a new proof from multiple quantum key sources
-    pub async fn new(
-        sources: &[ReporterEntry],
-        threshold: usize,
-        nonce: u64,
-    ) -> Result<Self, Box<dyn Error>> {
-        info!(
-            "Starting multi-source proof generation for {} sources (threshold: {})",
-            sources.len(),
-            threshold
-        );
-
-        // Create circuit manager
-        let circuit_manager = CircuitManager::new()?;
-
-        // Extract just the needed fields for the circuit
-        let source_count = sources.len() as u64;
-        
-        // Create validSources array with correct size (N from the circuit template)
-        let mut valid_sources = vec![0; 8];
-        for i in 0..std::cmp::min(sources.len(), 8) {
-            valid_sources[i] = 1; // Mark sources as valid up to our count
-        }
-        
-        // Create simplified input that matches circuit expectations
-        let input_json = json!({
-            "sourceCount": source_count,
-            "validSources": valid_sources
-        });
-
-        // Generate proof
-        let (proof, public_inputs) = circuit_manager.generate_proof("multi_source_key", input_json)?;
-
-        // Get verification key
-        let verification_key = circuit_manager.get_verification_key("multi_source_key")?;
-
-        // Extract commitment and VRF seed from public inputs
-        let inputs = public_inputs
-            .as_array()
-            .ok_or("Invalid public inputs format")?;
-        
-        // Check if we have enough elements
-        if inputs.len() < 2 {
-            // If we don't have enough elements, use default values
-            info!("Public inputs don't contain commitment and VRF seed, using defaults");
-            let combined_commitment = "default-commitment".to_string();
-            let vrf_seed = "default-seed".to_string();
-            info!("Using default commitment: {}", combined_commitment);
-            info!("Using default VRF seed: {}", vrf_seed);
-            
-            Ok(Self {
-                proof,
-                verification_key,
-                public_inputs,
-                combined_commitment,
-                vrf_seed,
-            })
-        } else {
-            // The last two elements should be combinedCommitment and vrfSeed
-            let combined_commitment = inputs
-                .get(inputs.len() - 2)
-                .and_then(|v| v.as_str())
-                .unwrap_or("unknown-commitment")
-                .to_string();
-            let vrf_seed = inputs
-                .get(inputs.len() - 1)
-                .and_then(|v| v.as_str())
-                .unwrap_or("unknown-seed")
-                .to_string();
-                
-            info!("Generated commitment: {}", combined_commitment);
-            info!("Generated VRF seed: {}", vrf_seed);
-            
-            Ok(Self {
-                proof,
-                verification_key,
-                public_inputs,
-                combined_commitment,
-                vrf_seed,
-            })
-        }
-    }
-
-    // Verify this multi-source proof
-    pub fn verify(&self) -> Result<bool, Box<dyn Error>> {
-        info!("Verifying multi-source proof...");
-        
-        // Create circuit manager
-        let circuit_manager = CircuitManager::new()?;
-        
-        // Verify using the circuit manager
-        let is_valid = circuit_manager.verify_proof(
-            "multi_source_key",
-            &self.proof,
-            &self.public_inputs
-        )?;
-        
-        if is_valid {
-            info!("✅ Multi-source proof verified successfully");
-        } else {
-            debug!("❌ Multi-source proof verification failed");
-        }
-        
-        Ok(is_valid)
-    }
-
-    // Export the proof and public inputs for third-party verification
-    pub fn export_for_verification(&self, path: &Path) -> Result<(), Box<dyn Error>> {
-        // Create circuit manager
-        let circuit_manager = CircuitManager::new()?;
-        
-        // Export using the circuit manager
-        circuit_manager.export_proof(
-            "multi_source_key",
-            &self.proof,
-            &self.public_inputs,
-            path
-        )?;
-        
-        // Add our additional fields
-        let mut export_data: Value = serde_json::from_str(&fs::read_to_string(path)?)?;
-        
-        if let Some(obj) = export_data.as_object_mut() {
-            obj.insert("combined_commitment".to_string(), json!(self.combined_commitment));
-            obj.insert("vrf_seed".to_string(), json!(self.vrf_seed));
-        }
-        
-        fs::write(path, serde_json::to_string_pretty(&export_data)?)?;
-        info!("Exported verification data to {:?}", path);
-        
-        Ok(())
-    }
-
-    // Get the combined commitment (for smart contracts, etc.)
-    pub fn get_commitment(&self) -> &str {
-        &self.combined_commitment
-    }
-
-    // Get the VRF seed
-    pub fn get_vrf_seed(&self) -> &str {
-        &self.vrf_seed
-    }
-}```
-### Circuit Definitions
-
-
-## File: circuits/vrf_seed_proof.circom
-
-```
-pragma circom 2.0.8;
-include "circomlib/poseidon.circom";
-include "circomlib/comparators.circom";
-
-// This circuit proves that a VRF seed incorporates a valid quantum key
-template VRFSeedProof() {
-    // Input: quantum key, input data, and VRF seed
-    signal input quantumKey;
-    signal input inputData;
-    signal input vrfSeed;
-    signal output isValid;
-    
-    // Hash the quantum key and input to get expected seed
-    component hasher = Poseidon(2);
-    hasher.inputs[0] <== quantumKey;
-    hasher.inputs[1] <== inputData;
-    
-    // Compare hash output with provided VRF seed
-    component comparator = IsEqual();
-    comparator.in[0] <== hasher.out;
-    comparator.in[1] <== vrfSeed;
-    
-    // Output 1 if valid, 0 if invalid
-    isValid <== comparator.out;
-}
-
-component main = VRFSeedProof();
-```
-
-
-## File: circuits/multi_source_key.circom
-
-```
-pragma circom 2.0.8;
-
-include "circomlib/comparators.circom";  
-include "circomlib/multiplexer.circom";  
-include "circomlib/bitify.circom";  
-include "circomlib/poseidon.circom";  
-
-template MultiSourceKey(N) {
-    signal input sourceCount;
-    signal input validSources[N];
-
-    signal output selectedKey;
-
-    // Define key hashers
-    component keyHashers[N];
-    signal keyHashes[N];  // Store Poseidon outputs
-
-    for (var i = 0; i < N; i++) {
-        keyHashers[i] = Poseidon(1);
-        keyHashers[i].inputs[0] <== validSources[i];  
-        keyHashes[i] <== keyHashers[i].out;  // Store Poseidon hash outputs
-    }
-
-    // Multiplexer to select the correct key
-    component keySelector = Multiplexer(1, N);  
-
-    // Ensure signal arrays match expected dimensions
-    signal keySelectorInp[N][1];
-    signal sourceActive[N];
-    signal selectionBits[N];  // ✅ Fixed multiple assignment issue
-    component sourceActiveCmp[N];
-
-    for (var i = 0; i < N; i++) {
-        sourceActiveCmp[i] = LessThan(8);
-        sourceActiveCmp[i].in[0] <== i;
-        sourceActiveCmp[i].in[1] <== sourceCount;
-        sourceActive[i] <== sourceActiveCmp[i].out;
-        
-        selectionBits[i] <== validSources[i] * sourceActive[i];  
-        keySelectorInp[i][0] <== keyHashes[i];  
-    }
-
-    keySelector.inp <== keySelectorInp;  
-    keySelector.sel <== selectionBits[0];  // ✅ Assign only ONE selector (fix T3001)
-    selectedKey <== keySelector.out[0];  
-}
-
-// ✅ Ensure this is added at the end
-component main = MultiSourceKey(8);
-
-```
-### ZK Utilities
