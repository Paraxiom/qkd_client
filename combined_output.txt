=== COMBINED LOGS AND CODE ===
>>> RUNTIME LOGS
================================================
Sun Feb 23 12:58:09 PM EST 2025
================================================
warning: unused import: `ark_bn254::Fr`
 --> src/quantum_auth/commitment.rs:1:5
  |
1 | use ark_bn254::Fr;
  |     ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `commitment::QuantumCommitment`
 --> src/quantum_auth/mod.rs:5:5
  |
5 | use commitment::QuantumCommitment;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::path::PathBuf`
 --> src/zk/proof.rs:7:5
  |
7 | use std::path::PathBuf;
  |     ^^^^^^^^^^^^^^^^^^

warning: variable does not need to be mutable
  --> src/quantum_auth/commitment.rs:13:13
   |
13 |         let mut value = [0u8; 32];
   |             ----^^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: `qkd_client` (lib) generated 4 warnings (run `cargo fix --lib -p qkd_client` to apply 4 suggestions)
warning: unused import: `std::path::PathBuf`
 --> src/zk/proof.rs:7:5
  |
7 | use std::path::PathBuf;
  |     ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `ark_bn254::Fr`
 --> src/quantum_auth/commitment.rs:1:5
  |
1 | use ark_bn254::Fr;
  |     ^^^^^^^^^^^^^

warning: variable does not need to be mutable
  --> src/main.rs:65:9
   |
65 |     let mut quantum_auth = QuantumAuthenticator::new()?;
   |         ----^^^^^^^^^^^^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: unused import: `ark_ff::PrimeField`
  --> src/main.rs:15:5
   |
15 | use ark_ff::PrimeField;
   |     ^^^^^^^^^^^^^^^^^^

warning: variable does not need to be mutable
  --> src/quantum_auth/commitment.rs:13:13
   |
13 |         let mut value = [0u8; 32];
   |             ----^^^^^
   |             |
   |             help: remove this `mut`

warning: function `build_test_circuit` is never used
 --> src/zk/circuit.rs:6:14
  |
6 | pub async fn build_test_circuit() -> Result<CircomCircuit<Fr>, Box<...
  |              ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: `qkd_client` (bin "qkd_client") generated 7 warnings (1 duplicate) (run `cargo fix --bin "qkd_client"` to apply 4 suggestions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/qkd_client`
ğŸŒŸ Testing connection...


ğŸ”„ Testing IP: 192.168.0.4

ğŸ” Trying connection to https://192.168.0.4/api/v1/keys/bobsae/enc_keys

ğŸ” Reading PKCS#12 file (client_alice.p12)...
ğŸ“‚ Opening file: /home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12
âœ… Successfully read 4494 bytes!

ğŸ” Reading CA cert...
ğŸ“‚ Opening file: /home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem
âœ… Successfully read 2155 bytes!
âœ… Generated quantum auth proof
ğŸ“¡ Sending request to: https://192.168.0.4/api/v1/keys/bobsae/enc_keys
Request Body: KeyRequest { sae_id: "bobsae", key_size: 256, number_of_keys: 1 }
[2m2025-02-23T17:58:09.546352Z[0m [35mTRACE[0m [2mhyper::client::pool[0m[2m:[0m checkout waiting for idle connection: ("https", 192.168.0.4)
[2m2025-02-23T17:58:09.546456Z[0m [35mTRACE[0m [2mhyper::client::connect::http[0m[2m:[0m Http::connect; scheme=Some("https"), host=Some("192.168.0.4"), port=None
[2m2025-02-23T17:58:09.546492Z[0m [34mDEBUG[0m [2mhyper::client::connect::http[0m[2m:[0m connecting to 192.168.0.4:443
[2m2025-02-23T17:58:09.546988Z[0m [34mDEBUG[0m [2mhyper::client::connect::http[0m[2m:[0m connected to 192.168.0.4:443
[2m2025-02-23T17:58:09.561994Z[0m [35mTRACE[0m [2mhyper::client::conn[0m[2m:[0m client handshake Http1
[2m2025-02-23T17:58:09.562044Z[0m [35mTRACE[0m [2mhyper::client::client[0m[2m:[0m handshake complete, spawning background dispatcher task
[2m2025-02-23T17:58:09.562187Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: Init, keep_alive: Busy }
[2m2025-02-23T17:58:09.562200Z[0m [35mTRACE[0m [2mhyper::client::pool[0m[2m:[0m checkout dropped for ("https", 192.168.0.4)
[2m2025-02-23T17:58:09.562377Z[0m [35mTRACE[0m [1mencode_headers[0m[2m:[0m [2mhyper::proto::h1::role[0m[2m:[0m Client::encode method=POST, body=Some(Known(53))
[2m2025-02-23T17:58:09.562461Z[0m [35mTRACE[0m [2mhyper::proto::h1::encode[0m[2m:[0m sized write, len = 53
[2m2025-02-23T17:58:09.562478Z[0m [35mTRACE[0m [2mhyper::proto::h1::io[0m[2m:[0m buffer.flatten [3mself.len[0m[2m=[0m192 [3mbuf.len[0m[2m=[0m53
[2m2025-02-23T17:58:09.562525Z[0m [34mDEBUG[0m [2mhyper::proto::h1::io[0m[2m:[0m flushed 245 bytes
[2m2025-02-23T17:58:09.562537Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: KeepAlive, keep_alive: Busy }
[2m2025-02-23T17:58:09.564946Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m Conn::read_head
[2m2025-02-23T17:58:09.565029Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: KeepAlive, keep_alive: Busy }
[2m2025-02-23T17:58:09.565503Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m Conn::read_head
[2m2025-02-23T17:58:09.565568Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: KeepAlive, keep_alive: Busy }
[2m2025-02-23T17:58:09.652093Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m Conn::read_head
[2m2025-02-23T17:58:09.652143Z[0m [35mTRACE[0m [2mhyper::proto::h1::io[0m[2m:[0m received 261 bytes
[2m2025-02-23T17:58:09.652188Z[0m [35mTRACE[0m [1mparse_headers[0m[2m:[0m [2mhyper::proto::h1::role[0m[2m:[0m Response.parse [3mbytes[0m[2m=[0m261
[2m2025-02-23T17:58:09.652227Z[0m [35mTRACE[0m [1mparse_headers[0m[2m:[0m [2mhyper::proto::h1::role[0m[2m:[0m Response.parse Complete(148)
[2m2025-02-23T17:58:09.652277Z[0m [34mDEBUG[0m [2mhyper::proto::h1::io[0m[2m:[0m parsed 5 headers
[2m2025-02-23T17:58:09.652288Z[0m [34mDEBUG[0m [2mhyper::proto::h1::conn[0m[2m:[0m incoming body is content-length (113 bytes)
[2m2025-02-23T17:58:09.652334Z[0m [35mTRACE[0m [2mhyper::proto::h1::decode[0m[2m:[0m decode; state=Length(113)
[2m2025-02-23T17:58:09.652347Z[0m [34mDEBUG[0m [2mhyper::proto::h1::conn[0m[2m:[0m incoming body completed
âœ… Got response!
[2m2025-02-23T17:58:09.652386Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m maybe_notify; read_from_io blocked
Status: 200 OK
Headers: {
    "server": "nginx",
    "date": "Sun, 23 Feb 2025 17:59:58 GMT",
    "content-type": "application/json",
    "content-length": "113",
    "connection": "keep-alive",
}
[2m2025-02-23T17:58:09.652426Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: Init, keep_alive: Idle }
[2m2025-02-23T17:58:09.652445Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: Init, keep_alive: Idle }
[2m2025-02-23T17:58:09.652471Z[0m [35mTRACE[0m [2mhyper::client::pool[0m[2m:[0m put; add idle connection for ("https", 192.168.0.4)
[2m2025-02-23T17:58:09.652487Z[0m [34mDEBUG[0m [2mhyper::client::pool[0m[2m:[0m pooling idle connection for ("https", 192.168.0.4)
Response body:
{"keys":[{"key_ID":"db67c562-b13a-463c-87b8-938f8a1b6da1","key":"56HjUMiS0hw1znm3LcKxE9pzAdKAsL0sszI8Wg7deK8="}]}
[2m2025-02-23T17:58:09.652563Z[0m [35mTRACE[0m [2mhyper::proto::h1::conn[0m[2m:[0m flushed({role=client}): State { reading: Init, writing: Init, keep_alive: Idle }

ğŸ‰ Success! Got keys:
ğŸ”‘ Key ID: db67c562-b13a-463c-87b8-938f8a1b6da1
ğŸ—ï¸  Key: 56HjUMiS0hw1znm3LcKxE9pzAdKAsL0sszI8Wg7deK8=
ğŸ“ Generating quantum-resistant proof...
Starting proof generation for key...
Key bytes length: 32
Verifying circuit files...
Created input file at "/home/paraxiom/qkd_client/circuits/input.json"
Generating witness...
[2m2025-02-23T17:58:09.654458Z[0m [35mTRACE[0m [2mhyper::client::pool[0m[2m:[0m idle interval checking for expired
âœ… Generated witness successfully
Generating proof...
âœ… Generated proof successfully
Reading proof and verification key...
âœ… Read proof and verification key successfully
âœ… Generated quantum-resistant proof
Starting proof verification...
Wrote verification files
Verifying proof...
âœ… Proof verified successfully
âœ… Proof verified successfully

>>> MAIN.RS CODE
================================================
use reqwest;
use reqwest::Certificate;
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::time::Duration;
mod zk;
use zk::KeyProof;
mod quantum_auth;
use quantum_auth::QuantumAuthenticator;
use tracing;
use tracing_subscriber::FmtSubscriber;
use ark_ff::PrimeField;

#[derive(Debug, Serialize)]
struct KeyRequest {
    sae_id: String,
    key_size: u32,
    number_of_keys: u32,
}

#[derive(Debug, Deserialize)]
struct Key {
    #[serde(rename = "key_ID")]
    key_id: String,
    key: String,
}

#[derive(Debug, Deserialize)]
struct KeyResponse {
    keys: Vec<Key>,
}

fn read_file(path: &Path) -> Result<Vec<u8>, std::io::Error> {
    println!("ğŸ“‚ Opening file: {}", path.display());
    let mut file = File::open(path)?;
    let mut contents = Vec::new();
    file.read_to_end(&mut contents)?;
    println!("âœ… Successfully read {} bytes!", contents.len());
    Ok(contents)
}

async fn try_connection(ip: &str, is_enc: bool) -> Result<(), Box<dyn Error>> {
    let url = if is_enc {
        format!("https://{}/api/v1/keys/bobsae/enc_keys", ip)
    } else {
        format!("https://{}/api/v1/keys/alicesae/dec_keys", ip)
    };
    println!("\nğŸ” Trying connection to {}", url);

    // PKCS#12 path + CA
    let p12_path =
        Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/client_alice.p12");
    let ca_path = Path::new("/home/paraxiom/qkd_client/certificate/Toshiba/certs/ca_crt.pem");

    println!("\nğŸ” Reading PKCS#12 file (client_alice.p12)...");
    let pkcs12_bytes = read_file(p12_path)?;

    println!("\nğŸ” Reading CA cert...");
    let ca_contents = read_file(ca_path)?;
    let ca_cert = Certificate::from_pem(&ca_contents)?;

    let mut quantum_auth = QuantumAuthenticator::new()?;
    let auth_proof = quantum_auth.authenticate()?;
    println!("âœ… Generated quantum auth proof");

    // Build client with certificates
    let client = reqwest::Client::builder()
        .add_root_certificate(ca_cert)
        .identity(reqwest::Identity::from_pkcs12_der(
            &pkcs12_bytes,
            "MySecret",
        )?)
        .danger_accept_invalid_certs(true)
        .danger_accept_invalid_hostnames(true)
        .timeout(Duration::from_secs(5))
        .build()?;

    let request = KeyRequest {
        sae_id: "bobsae".to_string(),
        key_size: 256,
        number_of_keys: 1,
    };

    println!("ğŸ“¡ Sending request to: {}", url);
    println!("Request Body: {:?}", request);

    let response = client
        .post(&url)
        .json(&request)
        .header("X-Quantum-Auth", base64::encode(&auth_proof))
        .send()
        .await?;

    println!("âœ… Got response!");
    let status = response.status();
    let headers = response.headers().clone();
    println!("Status: {}", status);
    println!("Headers: {:#?}", headers);

    let raw_text = response.text().await?;
    println!("Response body:\n{}", raw_text);

    if status.is_success() {
        match serde_json::from_str::<KeyResponse>(&raw_text) {
            Ok(key_response) => {
                println!("\nğŸ‰ Success! Got keys:");
                for key in key_response.keys {
                    println!("ğŸ”‘ Key ID: {}", key.key_id);
                    println!("ğŸ—ï¸  Key: {}", key.key);

                    // Generate quantum-resistant proof
                    println!("ğŸ“ Generating quantum-resistant proof...");
                    // In your key processing code
                    match KeyProof::new(&key.key).await {
                        Ok(key_proof) => {
                            println!("âœ… Generated quantum-resistant proof");
                            match key_proof.verify() {
                                Ok(true) => println!("âœ… Proof verified successfully"),
                                Ok(false) => println!("âŒ Proof verification failed"),
                                Err(e) => println!("âŒ Error verifying proof: {}", e),
                            }
                        }
                        Err(e) => println!("âŒ Error generating proof: {}", e),
                    }
                }
            }
            Err(e) => {
                println!("âŒ Error parsing response JSON: {}", e);
            }
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() {
    let subscriber = FmtSubscriber::builder()
        .with_max_level(tracing::Level::TRACE)
        .finish();
    tracing::subscriber::set_global_default(subscriber).expect("setting default subscriber failed");
    println!("ğŸŒŸ Testing connection...\n");
    let ip = "192.168.0.4";
    println!("\nğŸ”„ Testing IP: {}", ip);

    if let Err(e) = try_connection(ip, true).await {
        println!("âŒ Connection failed!");
        println!("Error: {}", e);
        if let Some(source) = e.source() {
            println!("Caused by: {}", source);
        }
    }
}
