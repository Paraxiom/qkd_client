use super::core::QuantumVRF;
use crate::quantum_auth::hybrid::HybridAuth;
use std::error::Error;
use tracing::{debug, info};

/// Response object from the VRF containing output and proofs
pub struct VRFResponse {
    /// The random output bytes generated by the VRF
    pub output: Vec<u8>,

    /// The proof that can be used to verify the output
    pub vrf_proof: Vec<u8>,
}

/// Verifiable Random Function with ZK integration
///
/// This implementation provides an integrated approach for generating
/// verifiable randomness that can be used in distributed applications.
pub struct IntegratedVRF {
    vrf: QuantumVRF,
}

impl IntegratedVRF {
    /// Create a new integrated VRF
    pub fn new(signer: HybridAuth) -> Self {
        Self {
            vrf: QuantumVRF::new(signer),
        }
    }

    /// Generate a VRF output with proof for verification
    pub fn generate_with_proof(
        &self,
        input: &[u8],
        quantum_key: &[u8],
    ) -> Result<VRFResponse, Box<dyn Error>> {
        debug!("Generating integrated VRF output and proof");

        // Generate VRF output and proof using underlying VRF implementation
        let (random_output, vrf_proof) = self.vrf.generate(input, quantum_key)?;

        // In a production system, we might add additional ZK proof generation here
        // to prove properties about the quantum key without revealing it

        info!(
            "Integrated VRF output generated: {} bytes, proof: {} bytes",
            random_output.len(),
            vrf_proof.len()
        );

        Ok(VRFResponse {
            output: random_output,
            vrf_proof,
        })
    }

    /// Verify a VRF response
    pub fn verify_with_proof(
        &self,
        input: &[u8],
        response: &VRFResponse,
        public_quantum_key: &[u8],
    ) -> Result<bool, Box<dyn Error>> {
        debug!("Verifying integrated VRF response");

        // Verify the VRF output using the core verification logic
        let result = self.vrf.verify(
            input,
            &response.output,
            &response.vrf_proof,
            public_quantum_key,
        )?;

        // In a production system, we might add additional ZK proof verification here

        info!(
            "Integrated VRF verification result: {}",
            if result { "valid" } else { "invalid" }
        );
        Ok(result)
    }

    /// Get the underlying VRF implementation
    pub fn get_vrf(&self) -> &QuantumVRF {
        &self.vrf
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_integrated_vrf() -> Result<(), Box<dyn Error>> {
        // Initialize auth system for testing
        let auth = HybridAuth::new()?;
        let vrf = IntegratedVRF::new(auth);

        // Test values
        let input = b"Test integrated VRF";
        let quantum_key = b"Quantum key for integrated testing";

        // Generate output and proof
        let response = vrf.generate_with_proof(input, quantum_key)?;

        // Verify the output
        let valid = vrf.verify_with_proof(input, &response, quantum_key)?;
        assert!(valid, "Integrated VRF verification should succeed");

        Ok(())
    }
}
