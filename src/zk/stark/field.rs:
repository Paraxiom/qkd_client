//! Finite field implementation for STARK proofs
use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};
use std::fmt;

/// Prime field element using the prime 2^64 - 2^32 + 1
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct FieldElement(pub u64);

// Field modulus: 2^64 - 2^32 + 1
const MODULUS: u128 = 0xFFFFFFFF00000001;

impl FieldElement {
    /// Creates a new field element
    pub fn new(value: u64) -> Self {
        // Reduce mod p
        let reduced_value = (value as u128) % MODULUS;
        FieldElement(reduced_value as u64)
    }

    /// Zero element
    pub fn zero() -> Self {
        FieldElement(0)
    }

    /// One element
    pub fn one() -> Self {
        FieldElement(1)
    }

    /// Compute the multiplicative inverse
    pub fn inverse(&self) -> Option<Self> {
        if self.0 == 0 {
            return None; // Zero has no inverse
        }

        // Extended Euclidean Algorithm to find inverse mod p
        let mut s = 0i128;
        let mut old_s = 1i128;
        let mut t = 1i128;
        let mut old_t = 0i128;
        let mut r = MODULUS as i128;
        let mut old_r = self.0 as i128;

        while r != 0 {
            let quotient = old_r / r;
            let tmp_r = r;
            r = old_r - quotient * r;
            old_r = tmp_r;

            let tmp_s = s;
            s = old_s - quotient * s;
            old_s = tmp_s;

            let tmp_t = t;
            t = old_t - quotient * t;
            old_t = tmp_t;
        }

        // Make sure we have the gcd = 1
        if old_r != 1 {
            return None;
        }

        // Convert result back to u64
        let inverse = if old_s < 0 {
            (old_s + MODULUS as i128) as u64
        } else {
            old_s as u64
        };

        Some(FieldElement(inverse))
    }

    /// Compute the square
    pub fn square(&self) -> Self {
        self.mul(*self)
    }

    /// Exponentiation by squaring
    pub fn pow(&self, exponent: u64) -> Self {
        if exponent == 0 {
            return FieldElement::one();
        }

        let mut result = FieldElement::one();
        let mut base = *self;
        let mut exp = exponent;

        while exp > 0 {
            if exp & 1 == 1 {
                result = result * base;
            }
            base = base.square();
            exp >>= 1;
        }

        result
    }

    /// Convert from bytes
    pub fn from_bytes(bytes: &[u8]) -> Self {
        let mut value = 0u64;
        for (i, &byte) in bytes.iter().enumerate().take(8) {
            value |= (byte as u64) << (i * 8);
        }
        FieldElement::new(value)
    }

    /// Convert to bytes
    pub fn to_bytes(&self) -> [u8; 8] {
        let mut bytes = [0u8; 8];
        let value = self.0;
        
        for i in 0..8 {
            bytes[i] = ((value >> (i * 8)) & 0xFF) as u8;
        }
        
        bytes
    }
}

// Implement standard arithmetic operations
impl Add for FieldElement {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        let result = (self.0 as u128 + rhs.0 as u128) % MODULUS;
        FieldElement(result as u64)
    }
}

impl AddAssign for FieldElement {
    fn add_assign(&mut self, rhs: Self) {
        *self = *self + rhs;
    }
}

impl Sub for FieldElement {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        let result = if self.0 >= rhs.0 {
            self.0 - rhs.0
        } else {
            MODULUS as u64 - (rhs.0 - self.0)
        };
        FieldElement(result)
    }
}

impl SubAssign for FieldElement {
    fn sub_assign(&mut self, rhs: Self) {
        *self = *self - rhs;
    }
}

impl Mul for FieldElement {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        let wide_result = (self.0 as u128) * (rhs.0 as u128) % MODULUS;
        FieldElement(wide_result as u64)
    }
}

impl MulAssign for FieldElement {
    fn mul_assign(&mut self, rhs: Self) {
        *self = *self * rhs;
    }
}

impl Div for FieldElement {
    type Output = Self;

    fn div(self, rhs: Self) -> Self {
        let inv = rhs.inverse()
            .expect("Attempted to divide by element with no inverse");
        self * inv
    }
}

impl DivAssign for FieldElement {
    fn div_assign(&mut self, rhs: Self) {
        *self = *self / rhs;
    }
}

impl Neg for FieldElement {
    type Output = Self;

    fn neg(self) -> Self {
        if self.0 == 0 {
            self
        } else {
            FieldElement(MODULUS as u64 - self.0)
        }
    }
}

impl fmt::Display for FieldElement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_field_arithmetic() {
        let a = FieldElement::new(5);
        let b = FieldElement::new(7);
        
        // Addition
        assert_eq!((a + b).0, 12);
        
        // Subtraction
        assert_eq!((b - a).0, 2);
        
        // Negation
        let neg_a = -a;
        assert_eq!((a + neg_a).0, 0);
        
        // Multiplication
        assert_eq!((a * b).0, 35);
        
        // Inverse and division
        let a_inv = a.inverse().unwrap();
        assert_eq!((a * a_inv).0, 1);
        assert_eq!((b / a).0, (b * a_inv).0);
    }

    #[test]
    fn test_field_pow() {
        let x = FieldElement::new(2);
        
        // x^0 = 1
        assert_eq!(x.pow(0).0, 1);
        
        // x^1 = x
        assert_eq!(x.pow(1).0, 2);
        
        // x^3 = 8
        assert_eq!(x.pow(3).0, 8);
        
        // x^10 = 1024
        assert_eq!(x.pow(10).0, 1024);
    }

    #[test]
    fn test_field_bytes() {
        let value = 0x0123456789ABCDEFu64;
        let fe = FieldElement::new(value);
        let bytes = fe.to_bytes();
        let fe2 = FieldElement::from_bytes(&bytes);
        assert_eq!(fe, fe2);
    }
}
